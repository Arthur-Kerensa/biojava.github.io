<p>Git is a very flexible versioning system. There are often multiple ways
to accomplish a task. Here are some recommended workflows for BioJava.</p>

<h2 id="using-github">Using github</h2>

<p>It is strongly advised to create a personal fork on github. This allows
new features to be fully developed before being merged into the main
repository. Some resources to help with this:</p>

<ul>
  <li><a href="https://help.github.com/articles/fork-a-repo">Github: Fork a repo</a></li>
  <li><a href="https://help.github.com/articles/using-pull-requests">Github: Using pull
requests</a></li>
</ul>

<h2 id="merging-options">Merging options</h2>

<p>Assume you are working in local fork, and that you have a remote ‘main’
which points to the main biojava repository:</p>

<p><code class="highlighter-rouge">$ git remote -v</code><br />
<code class="highlighter-rouge">main    https://github.com/biojava/biojava.git (fetch)</code><br />
<code class="highlighter-rouge">main    https://github.com/biojava/biojava.git (push)</code><br />
<code class="highlighter-rouge">origin  https://github.com/&lt;username&gt;/biojava-sbliven.git (fetch)</code><br />
<code class="highlighter-rouge">origin  https://github.com/&lt;username&gt;/biojava-sbliven.git (push)</code></p>

<p>You’ve started a branch ‘feature’ and made a few commits, so now your
repository now looks like this:</p>

<p><code class="highlighter-rouge">A -- B -- C &lt;- master, main/master</code><br />
<code class="highlighter-rouge">      \</code><br />
<code class="highlighter-rouge">       -- D -- E &lt;- feature</code></p>

<p>Now you want to merge your changes back into main/master. There are
several ways which this can be accomplished</p>

<ol>
  <li>Push the changes to your github fork, then issue a pull request</li>
  <li>Merge the feature branch into master locally, then push changes to
the main repository (requires developer permission)</li>
  <li>Rebase your changes onto master, then push changes to the main
repository (requires developer permission)</li>
</ol>

<p>All three options will result in the changes being published in the main
repository, but they have different side effects. Here are some rules of
thumb to follow for deciding which merge strategy to persue:</p>

<ul>
  <li>If you don’t have push access to the main repository, use pull
requests</li>
  <li>If the changes involve a major feature addition, use pull requests</li>
  <li>If any of the changes could be controversial, use pull requests</li>
  <li>For minor changes, use rebase</li>
</ul>

<h3 id="issuing-a-pull-request">Issuing a pull request</h3>

<p>Issuing a pull request is the easiest option. Just synchronize with your
github fork (<code class="highlighter-rouge">git push</code> or use the github application), then use the
github website to start a new pull request as described
<a href="https://help.github.com/articles/using-pull-requests">here</a>. Make sure
that biojava/master is the base repository, and your feature branch is
the head repository. If the changes are associated with a particular
issue, make sure to mention the issue number in the description box when
creating the pull request (eg ‘Fixing #12’).</p>

<p>Creating the pull request will generate a comment thread, much like an
issue. If an issue number was mentioned in the description, the original
issue will automatically get a link (eg ‘bob referenced this issue: Pull
Request #13’).</p>

<p>If the pull request can be automatically merged, go ahead and do so if
you have permission and don’t expect the merge to be controversial. If
the merge would result in conflicts, it may have to be manually merged
locally and then marked as resolved. Either way, merging will add a new
commit to the tree:</p>

<p><code class="highlighter-rouge">A -- B -- C ---- F &lt;- master, main/master</code><br />
<code class="highlighter-rouge">      \         /</code><br />
<code class="highlighter-rouge">       -- D -- E</code></p>

<p>Pros:</p>

<ul>
  <li>Creates a ticket on github for discussing the changes</li>
  <li>Doesn’t require push permission</li>
</ul>

<p>Cons:</p>

<ul>
  <li>Always adds a merge commit, complicating the repository history</li>
  <li>Requires the additional step of resolving the pull request</li>
  <li>Can’t be done from within Eclipse</li>
</ul>

<h3 id="manual-merging">Manual merging</h3>

<p>Creating pull requests may be overkill for some changes. Manually
merging avoids creating a full ticket on github. However, it’s more
dangerous since it directly modifies the main repository. Be absolutely
sure you understand how git merging works (see <a href="http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging">Git Book: Basic
Branching and
merging</a>).
Mistakes from this technique will be immediately public.</p>

<p>To manually merge, issue these commands:</p>

<p><code class="highlighter-rouge">git checkout master # switch to the destination branch</code><br />
<code class="highlighter-rouge">git pull main master # make sure its up-to-date</code><br />
<code class="highlighter-rouge">git merge --no-ff feature # merge the feature</code><br />
<code class="highlighter-rouge"># fix conflicts, check that everything looks good</code><br />
<code class="highlighter-rouge">git push main master # make changes public. Can't be undone!</code></p>

<p>Omitting the <code class="highlighter-rouge">--no-ff</code> parameter will skip adding a new merge commit if
no activity has happened on the main repository. This may or may not be
desirable.</p>

<p>Pros:</p>

<ul>
  <li>Complete control over the merge process</li>
  <li>Can be done from command line or eclipse</li>
  <li>Merge commit is optional for fast-forward merges</li>
</ul>

<p>Cons:</p>

<ul>
  <li>Usually needs a merge commit, complicating the repository history</li>
  <li>Mistakes are immediately public without review</li>
  <li>Needs developer permissions</li>
</ul>

<h3 id="using-rebase">Using rebase</h3>

<p>Rebasing gives very clean repository histories. Rather than merging two
lines of development, rebase applies all commits from one branch to the
head of the other branch, giving the illusion of one continuous line of
development. (See <a href="http://git-scm.com/book/en/Git-Branching-Rebasing">Git Book:
Rebasing</a>.) This
avoids the addition of many merge commits, which obscure real
developments in the git log.</p>

<p><code class="highlighter-rouge">git checkout feature # switch to the feature branch, unlike a merge</code><br />
<code class="highlighter-rouge">git rebase main/master feature # Moves all commits from the feature branch over to origin</code></p>

<p>At this point, main/master should be a parent of the feature branch:</p>

<p><code class="highlighter-rouge">A -- B -- C -- D' -- E' &lt;- feature</code><br />
<code class="highlighter-rouge">          ^\</code><br />
<code class="highlighter-rouge">            master, main/master</code></p>

<p>Now master can be moved up and pushed to the main repository</p>

<p><code class="highlighter-rouge">git checkout master</code><br />
<code class="highlighter-rouge">git merge feature # Fast-forward merge, so no commit message</code><br />
<code class="highlighter-rouge">git branch -d feature # Delete feature branch</code><br />
<code class="highlighter-rouge"># check that everything looks good and compiles</code><br />
<code class="highlighter-rouge">git push main master # make changes public. Can't be undone!</code></p>

<p>Pros:</p>

<ul>
  <li>Never requires a merge commit</li>
  <li>Simple linear history</li>
  <li>Complete control over the merge process</li>
</ul>

<p>Cons:</p>

<ul>
  <li>Mistakes are immediately public without review</li>
  <li>Needs developer permissions</li>
</ul>

