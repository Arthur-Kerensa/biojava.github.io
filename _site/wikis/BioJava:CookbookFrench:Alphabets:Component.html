<h2 id="comment-dcomposer-les-symbols-dun-crossproductalphabet-pour-obtenir-les-symbols-qui-les-constituent">Comment décomposer les Symbols d’un CrossProductAlphabet pour obtenir les Symbols qui les constituent?</h2>

<p>Les <em>CrossProductAlphabets</em> sont utilisés pour représenter des groupes
de <em>Symbols</em> comme un <em>Symbol</em> unique. C’est une façon très pratique de
traiter, par exemple, les codons comme des <em>Symbols</em> individuels.
Cependant, il est parfois nécessaire de reconvertir ces <em>Symbols</em> pour
obtenir à nouveau les <em>Symbols</em> qui les constituent. La recette qui suit
montre comment cela peut être fait.</p>

<p>Les <em>Symbols</em> d’un <em>CrossProductAlphabet</em> sont des implémentations de
l’interface <em>AtomicSymbol</em>. Le préfixe ‘Atomic’ suggère qu’un <em>Symbol</em>
ne peut être diviser alors comment faire pour subdiviser des <em>Symbols</em>
indivisibles en leur éléments constituants? La définition complète d’un
<em>AtomicSymbol</em> est qu’il ne peut être diviser en un <em>Symbol</em> plus simple
qui fait parti du même <em>Alphabet</em>. Les composantes qui ont construit un
<em>AtomicSymbol</em> d’un <em>CrossProductAlphabet</em> ne font pas partie de cet
<em>Alphabet</em>, par conséquent la définition d’ “Atomic” reste. Un codon
provient d’un <em>Alphabet</em> (ADN x ADN x ADN) alors que les composantes
d’un <em>Symbol</em> codon font parties de l’Alphabet ADN.</p>

<p>Cette situation contraste avec la définition d’un <em>BasisSymbol</em>. Un
<em>BasisSymbol</em> peut très bien être diviser en composantes qui font partie
du même <em>Alphabet</em>. de cette façon, un <em>BasisSymbol</em> peut être ambigüe.
Pour une discussion sur les <em>BasisSymbols</em>, cliquer ici.</p>

<java> package biojava\_in\_anger;

import java.util.\*; import org.biojava.bio.seq.\*; import
org.biojava.bio.symbol.\*;

public class BreakingComponents {

`   public static void main(String[] args) {`  
`       `  
`       // créer l'Alphabet "codon"`  
`       List l = Collections.nCopies(3, DNATools.getDNA());`  
`       Alphabet alpha = AlphabetManager.getCrossProductAlphabet(l);`  
`       `  
`             // obtenir le premier Symbol de cet Alphabet`  
`       Iterator iter = ((FiniteAlphabet)alpha).iterator();`  
`       AtomicSymbol codon = (AtomicSymbol)iter.next();`  
`       System.out.print(codon.getName()+" is made of: ");`  
`       `  
`       // décomposer pour obtenir une liste des composantes`  
`       List symbols = codon.getSymbols();`  
`       for(int i = 0; i &lt; symbols.size(); i++){`  
`           if(i != 0)`  
`               System.out.print(", ");`  
`           Symbol sym = (Symbol)symbols.get(i);`  
`           System.out.print(sym.getName());`  
`       }`  
`   }`

} </java>
