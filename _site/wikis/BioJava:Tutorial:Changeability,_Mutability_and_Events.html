<p><strong>By <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#109;&#114;&#112;&#064;&#115;&#097;&#110;&#103;&#101;&#114;&#046;&#097;&#099;&#046;&#117;&#107;">Matthew Pocock</a></strong></p>

<p>BioJava contains a powerful API for communicating when objects wish to
change their state, and potentialy preventing them from changing if it
would invalidate the state of another object, all without violating the
principals of encapsulation. The main classes are in the
<code class="highlighter-rouge">org.biojava.utils</code> package and include <code class="highlighter-rouge">Changeable</code>, <code class="highlighter-rouge">ChangeEvent</code>,
<code class="highlighter-rouge">ChangeListener</code>, <code class="highlighter-rouge">ChangeType</code> and <code class="highlighter-rouge">ChangeVetoException</code>. For full
descriptions of all the API used here, please consult the JavaDoc API
documentation (<a href="http://www.biojava.org/docs/api1.8/">latest biojava
1.8</a>).</p>

<h2 id="what-is-the-difference-between-changeability-and-mutability">What is the difference between Changeability and Mutability?</h2>

<p>Many Java objects are mutable. That is, you can invoke methods that
change their state. The Collections API supplys mutable implementations
of the <code class="highlighter-rouge">List</code> interface. There is also a method
<code class="highlighter-rouge">Collections.immutableList(List l)</code> that returns a view of the
underlying list where the mutators throw exceptions. Through this view
object there is no way to edit the list. However, if the underlying list
is modified then the ‘immutable’ view will reflect this. That is,
although it is immutable, it is still changeable.</p>

<p>Things get even more complicated in the world of bioinformatics. Many
instances need to be mutable with respect to some clients and immutable
for others. Also, some processes rely on objects remaining constant
throughout. You can’t perform a database search reliably if the database
is being modified. However, once the search is complete there is no
reason not to change the database. This transient immutability can’t be
modeled using the design pattern used for the collections. The situation
above is complicated even further because while a search is going on,
every single sequence must be maintained in an uneditable state.
However, a search object realy doesn’t want to go through the process of
modifying every single sequence object. This would be very ineficient.
Something more flexible is needed, and the <em>Changeability API</em> is it.</p>

<h2 id="what-is-a-changeevent">What is a ChangeEvent?</h2>

<p><code class="highlighter-rouge">ChangeEvent</code> extends <code class="highlighter-rouge">java.util.EventObject</code> and adds the methods:</p>

<ul>
  <li><code class="highlighter-rouge">getChange</code> - the new value</li>
  <li><code class="highlighter-rouge">getPrevious</code> - the old value</li>
  <li><code class="highlighter-rouge">getType</code> - the ‘type’ of event</li>
  <li><code class="highlighter-rouge">getChained</code> - an event that caused this event to be fired</li>
</ul>

<p>In constrast to the classical Java events model, one event class is
shared among all types of BioJava events. The ‘type’ of the event is
signaled by the value of the <code class="highlighter-rouge">type</code> property. <code class="highlighter-rouge">ChangeType</code> is a final
class. Each interface that will fire <code class="highlighter-rouge">ChangeEvents</code> will have
<code class="highlighter-rouge">public static final ChangeType</code> fields with descriptive names.
ChangeEvent objects store a descriptive name but are always compared
with the <code class="highlighter-rouge">==</code> operator. This scheme is a type-safe extention of the
Swing <code class="highlighter-rouge">PropertyChangeEvent</code> system but BioJava interfaces explicitly
publish what types of event they may fire.</p>

<h2 id="changelistener-the-contract-for-handling-events">ChangeListener: The contract for handling events</h2>

<p>Objects that wish to be informed of change events must implement the
<code class="highlighter-rouge">ChangeListener</code> interface. This has just two methods:</p>

<ul>
  <li><code class="highlighter-rouge">preChange(ChangeEvent ce)</code></li>
  <li><code class="highlighter-rouge">postChange(ChangeEvent ce)</code></li>
</ul>

<p>An object will invoke <code class="highlighter-rouge">preChange</code> to inform listeners that it wishes to
alter its state. A <code class="highlighter-rouge">ChangeListener</code> may fire a <code class="highlighter-rouge">ChangeVetoException</code> to
prevent this change from taking place. The event source must respect
this. Once the event source has finished updating its state, it will
invoke the <code class="highlighter-rouge">postChangeEvent</code> method with an equivalent <code class="highlighter-rouge">ChangeEvent</code>
(one with the same values for its properties). The <code class="highlighter-rouge">postChange</code> method
should then take appropriate action to update the state of the listening
object.</p>

<p>There are two <code class="highlighter-rouge">ChangeListener</code> implementations supplied by default.
<code class="highlighter-rouge">ChangeListener.ALWAYS_VETO</code> always throws a <code class="highlighter-rouge">ChangeException</code> in
<code class="highlighter-rouge">preChange</code>. This object is useful if you wish to unconditionally lock
an object’s property. In the exceptional circumstance when
<code class="highlighter-rouge">ChangeListener.ALWAYS_VETO</code> is registered and a <code class="highlighter-rouge">postChange</code> is
reached, it throws a <code class="highlighter-rouge">NestedError</code> with an assertion failure message.
This should only be able to happen if the event source is incorrectly
implemented.</p>

<p><code class="highlighter-rouge">ChangeException.LOG_TO_OUT</code> prints all changes out to <code class="highlighter-rouge">System.out</code>. If
you want to log to a different stream, construct a new instance of
<code class="highlighter-rouge">ChangeListener.LoggingListener</code> with the stream.</p>

<h2 id="using-changesupport-to-implement-changeable">Using ChangeSupport to implement Changeable</h2>

<p>To flag that an object is a source of change events, it should implement
<code class="highlighter-rouge">Changeable</code>. This interface has the following methods:</p>

<ul>
  <li><code class="highlighter-rouge">addChangeListener(ChangeListener cl)</code></li>
  <li><code class="highlighter-rouge">addChangeListener(ChangeListener cl, ChangeType ct)</code></li>
  <li><code class="highlighter-rouge">removeChangeListener(ChangeListener cl)</code></li>
  <li><code class="highlighter-rouge">removeChangeListener(ChangeListener cl, ChangeType ct)</code></li>
</ul>

<p>The methods with <code class="highlighter-rouge">ChangeType</code> arguments register the listener for that
type of event only. The methods without register the listener for all
events. Wherever possible, the type of event should be specified. This
potentialy allows for lazy instantiation of various resources and will
result in fewer events actualy being fired.</p>

<p><code class="highlighter-rouge">ChangeSupport</code> is a utility class that handles 99% of the cases where
you wish to implement the <code class="highlighter-rouge">Changeable</code> interface. Idealy, you should
instantiate one of these objects and then delegate the listener methods
to this. In addition to the methods in <code class="highlighter-rouge">Changeable</code>, <code class="highlighter-rouge">ChangeSupport</code>
supplys the methods:</p>

<ul>
  <li><code class="highlighter-rouge">firePreChangeEvent(ChangeEvent ce)</code></li>
  <li><code class="highlighter-rouge">firePostChangeEvent(ChangeEvent ce)</code></li>
</ul>

<p>These methods invoke the <code class="highlighter-rouge">preChange</code> and <code class="highlighter-rouge">postChange</code> methods of the
apropreate listeners. <code class="highlighter-rouge">firePreChangeEvent</code> will pass on any
<code class="highlighter-rouge">ChangeVetoExceptions</code> that the listeners throw.</p>

<p><code class="highlighter-rouge">AbstractChangeable</code> is an abstract implementation of <code class="highlighter-rouge">Changeable</code> that
delegates to a <code class="highlighter-rouge">ChangeSupport</code>. In the cases where your class does not
have to inherit from any class but must implement <code class="highlighter-rouge">Changeable</code>, this is
a perfect base class. It will lazily instantiate the delegate only when
listeners need to be registered.</p>

<p>In the <a href="BioJava:Tutorial:ChangeEvent_example_using_Distribution_objects" title="wikilink">next
tutorial</a>,
we will implement an event source and add some listeners to it.</p>

<category:tutorial>
</category:tutorial>
