<h2 id="comment-crer-une-caractristique-feature">Comment créer une caractéristique (<em>Feature</em>)?</h2>

<p>Dans BioJava, les <em>Features</em> sont un peu comme des <em>Annotation</em> mais
avec une position (<em>Location</em>). Il existe plusieurs types de <em>Features</em>
qui tous implémentent l’interface <em>Feature</em>. Toutes les implémentations
de <em>Feature</em> contiennent une classe interne appellée ‘Template’. Cette
classe <em>Template</em> spécifie le contenu minimum en information nécessaire
pour créer un <em>Feature</em>. Une caractéristique (un <em>Feature</em>) est créer
lorsque le patron du <em>Feature</em> est passer en argument à la méthode
<strong>createFeature(Feature templ)</strong> d’une implémentation de l’interface
<em>FeatureHolder</em>.</p>

<p>En pratique, la classe <em>Sequence</em> est un sous-interface de
<em>FeatureHolder</em>, afin de lui permettre de contenir des <em>Features</em>. Noter
cependant qu’un objet <em>SymbolList</em> ne peut contenir de <em>Features</em>. Une
autre particuliarité intéressante est le fait que l’interface <em>Feature</em>
est aussi un sous-interface de <em>FeatureHolder</em>. Ceci permet donc à un
objet <em>Feature</em> de contenir des sous-<em>Features</em> dans une hiérarchie
imbriquée. Ainsi, un <em>Feature</em> ‘gene’ peut contenir des <em>Features</em>
‘exon’ qui eux-même peuvent contenir des <em>Features</em> ‘snp’ et ainsi de
suite. Un mécanisme de sureté construit à même la classe empêche un
<em>Feature</em> de ce contenir lui-même.</p>

<p>Les gabarits de <em>Feature</em> peuvent être crées de novo ou copiés à partir
d’un <em>Feature</em> déjà existant; l’exemple qui suit montre les deux
méthodes.</p>

<java> import org.biojava.bio.\*; import org.biojava.bio.seq.\*; import
org.biojava.bio.symbol.\*; import org.biojava.utils.\*;

public class MakeAFeature {

` public static void main(String[] args) {`  
`   //obtenir le gabarit du Feature pour un StrandedFeature`  
`   StrandedFeature.Template templ = new StrandedFeature.Template();`

`   //remplir l"info pour ce gabarit`  
`   templ.annotation = Annotation.EMPTY_ANNOTATION;`  
`   templ.location = new RangeLocation(3,6);`  
`   templ.source = "my feature";`  
`   templ.strand = StrandedFeature.POSITIVE;`  
`   templ.type = "interesting motif";`

`   try {`  
`     //la séquence qui va avoir ce Feature`  
`     Sequence seq = DNATools.createDNASequence("atgcgcttaag","seq1");`  
`     System.out.println(seq.getName()+" contains "+seq.countFeatures()+" features");`

`     System.out.println("adding new feature...");`

`     //créer ce Feature sur cette séquence et obtenir un pointeur qui nous permettra d'en faire un autre`  
`     Feature f = seq.createFeature(templ);`  
`     System.out.println(seq.getName()+" contains "+seq.countFeatures()+" features");`

`     //créer un gabarit identique à celui utilisé pour faire f`  
`     templ = (StrandedFeature.Template)f.makeTemplate();`  
`     //on lui donne une position et un nom différent`  
`     templ.location = new PointLocation(4);`  
`     templ.type = "point mutation";`

`     System.out.println("adding nested feature...");`  
`     //ajouter ce nouveau Feature comme imbriqué dans f`  
`     f.createFeature(templ);`

`     //observer que countFeatures() ne compte que les Features de 1er niveau`  
`     System.out.println(seq.getName()+" contains "+seq.countFeatures()+" features");`  
`     System.out.println(f.getSource()+" contains "+seq.countFeatures()+" features");`  
`   }`  
`   catch (Exception ex) {`  
`     ex.printStackTrace();`  
`   }`  
` }`

} </java>
