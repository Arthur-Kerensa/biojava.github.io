<p>We need to organize the source in such a way that we know how and where
to find things. To a certain extent, we can do this with package
namespaces, but when we get a lot of packages, things can become a bit
blurry.</p>

<p>Note that <em>source division</em> simply describes how the source is
divided up, not specifically any architectural divisions (although,
naturally, they do parallel - see below where they diverge.)</p>

<h2 id="approach">Approach</h2>

<p>We can use the Eclipse <em>Source Directory</em> feature to divide the
source into larger, very apparent divisions.</p>

<p>Source basically falls into five recognizable major categories. These
are listed here, along with the architectural groups that fall within
them:</p>

<p><img src="MBTCodeDivision.png" alt="" title="fig:MBTCodeDivision.png" /></p>

<p>While these tend to mostly follow architectural lines, two divisions
follow toolkit implementation lines, specifically the <em>UI</em> and <em>GL
Scene</em> divisions.</p>

<p>This is because they are each implemented with a toolkit -
<em>Swing</em> and <em>OpenGL</em> respectively. We want to isolate
these specifically, to allow us to replace them, should we desire. Also,
we can use this as a check to see if too much controller/model or other
application internal implementation is creeping in here.</p>

<p>Ideally, these code divisions should:</p>

<ul>
  <li>Be the <em>only</em> place where the implementing toolkit code
resides.</li>
  <li>Contain as little application-implementation code as possible.</li>
</ul>

<p>Note in the case of the <em>GL Scene</em>, this is currently not the
case - in the future, we may want to break this down into <em>Scene</em>
and <em>GL Scene</em> for generic scene implementation (if there is such
a thing) and <em>OpenGL</em>-scene implementation, respectively.</p>

<p>Note that the source division described here is mirrored in all the
projects. Thus, if a viewer app wants to derive a controller that is
defined in a support library, that app should locate that source (and
the appropriate package name) in the same named folder as the base class
is contained in the support lib.</p>

<h2 id="package-naming-convention">Package Naming Convention</h2>

<p>Packages are currently prefaced with org.rcsb.*. After that initial
organization identifier, the packages are identified with a ‘n’ letter
code, depending on which project it belongs to:</p>

<ul>
  <li><em>mbt</em> - MBT Libs project</li>
  <li><em>uiApp</em> - UIApp Framework project</li>
  <li><em>vf</em> - Viewer Framework project</li>
  <li><em>sv</em> - Simple Viewer project</li>
  <li><em>pw</em> - Protein Workshop project</li>
  <li><em>lx</em> - Ligand Explorer project</li>
  <li><em>ks</em> - Kiosk Viewer project</li>
</ul>

<p>New libraries or applications should add their own identifying code to
the package namespace.</p>

<h2 id="extra-division---structure-loader">Extra Division - Structure Loader</h2>

<p>The <em>Structure Loader</em> is a fairly large subsystem in and of
itself - thus it seemed appropriate to put it in its own division.&lt;/a&gt;
In architectural terms, technically, it could be considered part of the
<em>DocController</em>, but breaking it out keeps it all together as a
mechanism <em>used</em> by the <em>DocController</em> without cluttering
up that code with too much detail.</p>

<h2 id="jar-division-reflects-projects-division">Jar Division Reflects Projects Division</h2>

<p>Ultimately the MBT is output to one or more jars for loading into an
application. An application shouldn’t have to load any more code than it
needs - thus, the multiple jars are created reflecting the code
division.</p>

<p>Each project represents a jarfile. Thus, a UI only app, does not need
the functionality provided in the <em>Viewer Framework</em>, a command-line
analysis tool does not need the functionality provided in either the
<em>UIApp Framework</em> or the <em>Viewer Framework.</em></p>
