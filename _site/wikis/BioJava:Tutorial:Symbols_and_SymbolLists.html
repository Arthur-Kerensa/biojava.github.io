<p><strong>By <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#116;&#100;&#050;&#064;&#115;&#097;&#110;&#103;&#101;&#114;&#046;&#097;&#099;&#046;&#117;&#107;">Thomas Down</a></strong></p>

<p>This chapter covers the fundamentals of accessing biological sequence
data from BioJava, and explains how BioJava’s treatment of sequences
differs from other libraries. This chapter refers to Java API defined in
the packages <code class="highlighter-rouge">org.biojava.bio.symbol</code> and <code class="highlighter-rouge">org.biojava.bio.seq</code>. For a
complete overview of the APIs provided by these packages, please consult
the JavaDoc API documentation (<a href="http://www.biojava.org/docs/api1.8/">latest biojava
1.8</a>).</p>

<h2 id="symbols-and-alphabets">Symbols and Alphabets</h2>

<p>When biological sequence data first became available, it was necessary
to find a convenient way to communicate it. A logical approach is to
represent each monomer in a biological macromolecule using a single
letter - usually the initial letter of the chemical entity being
described, for instance ‘T’ for thymidine residues in DNA. When this
data was entered into computers, it was logical to use the same scheme.
A lot of computational biology software is based on normal string
handling APIs. While the notion of a sequence as a string of ASCII
characters has served us well to date, there are several issues which
can present problems to the programmer:</p>

<p>Validation: It is possible to pass <em>any</em> string to a routine which is expecting a biological sequence. Any validation has to be performed on an <em>ad hoc</em> basis.<br />
Ambiguity: The meaning of each symbol is not necessarily clear. The ‘T’ which means thymidine in DNA is the same ‘T’ which is a threonine residue in a protein sequence<br />
Limited alphabet: While there are obvious encodings for nucleic acid and sequence data as strings, the same approach does not always work well for other kinds of data generated in biological sequence analysis software</p>

<p>BioJava takes a rather different approach to sequence data. Instead of
using a string of ASCII characters, a sequence is modelled as a list of
Java objects implementing the <code class="highlighter-rouge">Symbol</code> interface. This class, and the
others described here, are part of the Java package
<code class="highlighter-rouge">org.biojava.bio.symbol</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface Symbol {
    public String getName();
    public Annotation getAnnotation();
    public Alphabet getMatches();
}
</code></pre>
</div>

<p>All <code class="highlighter-rouge">Symbol</code> instances have a <code class="highlighter-rouge">name</code> property (for instance, Thymidine).
They may optionally have extra information associated with them (for
instance, information about the chemical properties of a DNA base)
stored in a standard BioJava data structure called an <code class="highlighter-rouge">Annotation</code>.
Annotations are just set of key-value data. The final method,
<code class="highlighter-rouge">getMatches</code>, is only important for ambiguous symbols, which are covered
at the end of this chapter.</p>

<p>The set of <code class="highlighter-rouge">Symbol</code> objects which may be found in a particular type of
sequence data are defined in an <code class="highlighter-rouge">Alphabet</code>. It is always possible to
define custom symbols and alphabets, but BioJava supplies a set of
predefined alphabets for representing biological molecules. These are
accessible through a central registry called the <code class="highlighter-rouge">AlphabetManager</code>, and
through convenience methods.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FiniteAlphabet dna = DNATools.getDNA();
Iterator dnaSymbols = dna.iterator();
while (dnaSymbols.hasNext()) {
    Symbol s = (Symbol) dnaSymbols.next();
    System.out.println(s.getName());
}
</code></pre>
</div>

<h2 id="symbollist-the-simple-sequence">SymbolList: the simple sequence</h2>

<p>The basic interface for sequence data in BioJava is <code class="highlighter-rouge">SymbolList</code>. Every
symbol list has an associated alphabet, and may only contain symbols
from that alphabet. Symbol lists can be seen as strings which are made
up of <code class="highlighter-rouge">Symbol</code> objects rather than characters. The interface specifies
methods for querying the alphabet and length, and accessing the symbols:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SymbolList seq = getSomeSequence();
System.out.println("Alphabet = " + seq.getAlphabet().getName());
System.out.println("Length = " + seq.length());
System.out.println("First symbol = " + seq.symbolAt(1).getName());
</code></pre>
</div>

<p>Note that numbering of symbols within the symbol list runs from 1 to
<code class="highlighter-rouge">length</code>, <em>not</em> from 0 to <code class="highlighter-rouge">length - 1</code> as is the case with Java strings.
This is consistent with the coordinate system found in files of
annotated biological sequences.</p>

<p>There are several other standard methods in the <code class="highlighter-rouge">SymbolList</code> interface.
<code class="highlighter-rouge">subList</code> returns a new symbol list representing part of the sequence,
just like the <code class="highlighter-rouge">substring</code> method of the <code class="highlighter-rouge">String</code> class. <code class="highlighter-rouge">seqString</code>
returns a normal string representation of the sequence. This latter
method will only work if the symbol list uses an alphabet where all
symbols have their <code class="highlighter-rouge">token</code> property defined. However, since this is true
of the commonly used DNA and protein alphabets, this method is useful if
you need interaction between BioJava and legacy sequence analysis code.</p>

<p>The <code class="highlighter-rouge">SymbolList</code> interface does not define any methods for modifying the
underlying sequence data. Future versions of BioJava may also include a
<code class="highlighter-rouge">MutableSymbolList</code> interface.</p>

<h2 id="doesnt-this-all-waste-memory">Doesn’t this all waste memory?</h2>

<p><img src="Symbol_Singleton.png" alt="A SymbolList can be stored as a list of references to singleton
objects" title="A SymbolList can be stored as a list of references to singleton objects" /></p>

<p>A common concern with BioJava’s <code class="highlighter-rouge">Symbol</code>/<code class="highlighter-rouge">SymbolList</code> model is that it
must use much more memory than a simple string-based approach to
sequence storage. It should be stressed that BioJava does <em>not</em> use a
separate object to represent each nucleotide in a long DNA sequence. In
fact, there are just four ‘singleton’ <code class="highlighter-rouge">Symbol</code> objects which represent
the symbols found in the DNA alphabet. These can be accessed at any time
using static methods of the <code class="highlighter-rouge">DNATools</code> class. Whenever a thymidine
residue is stored in a sequence, all that is really stored is a
<em>reference</em> to the singleton thymidine object. Typically, this takes up
four bytes of memory: more than the two bytes used by a Java <code class="highlighter-rouge">char</code>, but
still manageable.</p>

<p>Actually, it is possible in principle to store a DNA sequence (without
gaps or ambiguous residues) using only two <em>bits</em> per residue. Since the
BioJava <code class="highlighter-rouge">SymbolList</code> is an interface, it only defines how the sequence
should be accessed - not how data is stored. If space is important, it
is possible to implement a ‘packed’ implementation of <code class="highlighter-rouge">SymbolList</code>.
Client code need never worry about the underlying data model.</p>

<p>BioJava’s object oriented view of sequences brings other advantages.
Many programs which analyse DNA sequences need to have simultaneous
access to the original sequence and that of its complementary strand. In
BioJava this is easy.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SymbolList forward = getSequence();
SymbolList backward = DNATools.reverseComplement(forward);
System.out.println("First base: " + forward.symbolAt(1).getName());
System.out.println("Complement: " + backward.symbolAt(backward.length()).getName());
</code></pre>
</div>

<p>Since the reverse complement of a DNA sequence is a simple programmatic
transformation, BioJava doesn’t need to physically store the sequence in
memory at all. Instead, it just creates a special implementation of the
<code class="highlighter-rouge">SymbolList</code> interface, which computes the reverse strand sequence on
the fly. This will typically cost just a few bytes of memory regardless
of the sequence length, compared to megabytes for a string
representation of a typical genome sequence.</p>

<h2 id="how-do-i-access-my-sequence-data">How do I access my sequence data?</h2>

<p>Each <code class="highlighter-rouge">Alphabet</code> object can have one or more <code class="highlighter-rouge">SymbolTokenization</code>
implementations associated. These are two-way mappings between <code class="highlighter-rouge">Symbol</code>
objects and textual representations of the data. They are the primary
mechanism for creating new symbol lists from existing
(character-encoded) sequence data. By convention, any alphabet which has
a commonly accepted textual representation has a symbol tokenization
called ‘token’ associated:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>String seqString = "GATTACA";
Alphabet dna = DNATools.getDNA();
SymbolTokenization dnaToke = dna.getTokenization("token");
SymbolList seq = new SimpleSymbolList(dnaToke, seqString);
String seqString2 = dnaToke.tokenizeSymbolList(seq);
System.out.println("Strings match: " + seqString2.equalsIgnoreCase(seqString));
</code></pre>
</div>

<p>This low-level parsing mechanism is supplemented by a more sophisticated
sequence Input/Output framework, defined in the package
<code class="highlighter-rouge">org.biojava.bio.seq.io</code>. This uses pluggable file format converters,
and can currently read and write in Fasta, EMBL, and Genbank formats.
BioJava can also fetch data from services such as DAS using
<a href="http://www.derkholm.net/thomas/dazzle">Dazzle</a>, and access databases
such as Genbank and BioSQL as well those used by the
<a href="http://www.ensembl.org/">Ensembl</a> project (additional packages are
required to support DAS and Ensembl).</p>

<h2 id="what-about-the-sequence-interface">What about the Sequence interface?</h2>

<p>Until this point, we have concentrated on the <code class="highlighter-rouge">SymbolList</code> interface
which, as its name suggests, is a raw list of <code class="highlighter-rouge">Symbol</code> references. Real
entries in sequence databases are more complicated than this: sequences
almost always have some kind of ID code or description associated, and
many are also accompanied by tables of annotations. In BioJava,
<code class="highlighter-rouge">Sequence</code> is a subinterface of <code class="highlighter-rouge">SymbolList</code> which adds a <code class="highlighter-rouge">name</code>
property, plus a mechanism for querying tables of features.</p>

<p>The general rule is that the <code class="highlighter-rouge">Sequence</code> interface is normally used for
sequences which have been loaded into a program from files or databases.
<code class="highlighter-rouge">SymbolList</code> may be a more appropriate type for sequences generated
internally by an analysis program.</p>

<h2 id="a-simple-example">A simple example</h2>

<p>The following program is a very simple example, which reads one or more
DNA sequences from a FASTA format data file and reports the GC content
of each. This example is a (very) simple application of the BioJava
Sequence I/O framework, described in later chapters. Used as below, it
allows you to iterate over all the sequences in a multiple-entry file,
rather than holding all of them in memory at once.</p>

<java>import java.io.\*; import org.biojava.bio.symbol.\*; import
org.biojava.bio.seq.\*; import org.biojava.bio.seq.io.\*;

public class GCContent {

`   public static void main(String[] args)`  
`       throws Exception`  
`   {`  
`       if (args.length != 1)`  
`       throw new Exception("usage: java GCContent filename.fa");`  
`   String fileName = args[0];`  
`      `  
`   // Set up sequence iterator`

`   BufferedReader br = new BufferedReader(`  
`                   new FileReader(fileName));`  
`   SequenceIterator stream = SeqIOTools.readFastaDNA(br);`

`   // Iterate over all sequences in the stream`

`   while (stream.hasNext()) {`  
`       Sequence seq = stream.nextSequence();`  
`       int gc = 0;`  
`       for (int pos = 1; pos &lt;= seq.length(); ++pos) {`  
`       Symbol sym = seq.symbolAt(pos);`  
`       if (sym == DNATools.g() || sym == DNATools.c())`  
`           ++gc;`  
`       }`  
`       System.out.println(seq.getName() + ": " + `  
`                  ((gc * 100.0) / seq.length()) + `  
`                  "%");`  
`   }`  
`   }                  `

}</java>

<h2 id="ambiguous-symbols">Ambiguous symbols</h2>

<p>Sometimes, it is useful to represent sequences which are not perfectly
defined. In such cases, it is common to use <em>ambiguous</em> symbols. A
common example is the ‘N’ character in DNA sequences, which is used to
indicate parts of a sequence where the sequencing traces were difficult
to interpret. Sometimes, runs of Ns are also used to indicate gaps in
assemblies. In the case of DNA, additional ambiguity symbols have been
defined, covering all possible combinations of the four bases. For
instance, the symbol ‘W’ realy means (A or T).</p>

<p>Within the BioJava object model, it is possible to inspect any ambiguous
symbol to determine the set of atomic symbols which it matches, using
the <code class="highlighter-rouge">getMatches</code> method. Atomic symbols can be considered to be the
special case where <code class="highlighter-rouge">getMatches</code> returns a set whose size is exactly one.
As a conveniece, atomic symbols also implement the <code class="highlighter-rouge">AtomicSymbol</code>
interfaces.</p>

<p>You might want to modify the GCContent program, above, so as to ignore
any ambiguous symbols in the input sequence.</p>

<category:tutorial>
</category:tutorial>
