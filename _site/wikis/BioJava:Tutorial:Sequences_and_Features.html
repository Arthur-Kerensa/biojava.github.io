<p><strong>By <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#116;&#100;&#050;&#064;&#115;&#097;&#110;&#103;&#101;&#114;&#046;&#097;&#099;&#046;&#117;&#107;">Thomas Down</a></strong></p>

<p><a href="BioJava:Tutorial:Symbols and SymbolLists" title="wikilink">Chapter 1</a> of this
tutorial covered the <code class="highlighter-rouge">SymbolList</code> interface, BioJava’s basic
representation of biological sequence data. This chapter examines the
<code class="highlighter-rouge">Sequence</code> interface. This adds extra functionality to <code class="highlighter-rouge">SymbolList</code>,
providing a convenient way to handle annotated sequences from biological
database. This chapter concentrates on classes and interfaces defined in
the package <code class="highlighter-rouge">org.biojava.bio.seq</code>. For full descriptions of all the API
used here, please consult the JavaDoc API documentation (<a href="http://www.biojava.org/docs/api1.8/">latest biojava
1.8</a>).</p>

<h2 id="a-tour-of-a-sequence">A tour of a Sequence</h2>

<p><code class="highlighter-rouge">Sequence</code> is a sub-interface of <code class="highlighter-rouge">SymbolList</code>. Thus, all the standard
methods for accessing sequence data in a symbol list can equally be
applied to a sequence, and sequences can be passed to any analysis
methods which normally expect to receive a symbol list. The <code class="highlighter-rouge">Sequence</code>
interface adds two types of additional data to a symbol list:</p>

<ul>
  <li>Global annotations, such as names, database identifiers, and
literature references</li>
  <li>Location-specific annotations (so called <em>features</em>)</li>
</ul>

<p>Two pieces of global annotation information are considered to be
sufficiently important that they have dedicated accessor methods. The
<code class="highlighter-rouge">name</code> of the sequence is a simple string description of the sequence:
normally the name or accession number of the sequence in the database
from which it is retrieved. The <code class="highlighter-rouge">getURN</code> method, on the other hand,
should return a more structured identifier for the sequence, represented
as a <em>Uniform Resource Identifier</em> (URI) e.g.:</p>

<ul>
  <li><code class="highlighter-rouge">urn:sequence/embl:AL121903</code></li>
  <li><code class="highlighter-rouge">file:///home/thomas/genome.fasta|rpoN</code></li>
  <li><code class="highlighter-rouge">&lt;nowiki&gt;http://adzel.casseiopeia.org/seqs/myseqs.fasta|seq0001&lt;/nowiki&gt;</code></li>
  <li><code class="highlighter-rouge">acedb://humace.sanger.ac.uk/DNA/AL121903</code></li>
</ul>

<p>URNs are a special class of URIs which represent global names for ‘well
known’ resources. Note that, despite the method name, it may not be
appropriate to give an actual URN for sequences. However, for sequences
from databases such as EMBL, where many sites have local installations,
use of URNs is encouraged.</p>

<p>The exact use of the name and URN properties is currently dependent to
some extent on how the sequence was loaded. As BioJava enters more
common use, more formal definitions of these properties will emerge.</p>

<h2 id="other-annotations">Other annotations</h2>

<p>In additions to the two ‘identifier’ properties of the sequence, it may
have other annotation data associated with it. BioJava contains an
<code class="highlighter-rouge">Annotation</code> interface, which represents a set of key-value pairs, a
little like a Java <code class="highlighter-rouge">Map</code> (indeed, Annotation has an <code class="highlighter-rouge">asMap</code> method).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Sequence seq = getSequence();
Annotation seqAn = seq.getAnnotation();
for (Iterator i = seqAn.keys().iterator(); i.hasNext(); ) {
    Object key = i.next();
    Object value = seqAn.getProperty(key);
    System.out.println(key.toString() + ": " + value.toString());
}
</code></pre>
</div>

<p><code class="highlighter-rouge">Annotation</code> objects aren’t just used in sequences - many other BioJava
objects, including <code class="highlighter-rouge">Features</code>, can also have annotations associated with
them.</p>

<p>Currently, there are no specific conventions for the kind of data which
might be found in an annotation. In general, the keys should be strings
(although there is no requirement that this be the case). But the values
may be any Java object. More guidelines for the contents of <code class="highlighter-rouge">Annotation</code>
objects may be introduced as BioJava develops.</p>

<h2 id="features-and-featureholders">Features and FeatureHolders</h2>

<p>A feature represents a region of a sequence with some defined properties
attached. Typically, features might represent structures such as genes
and repeat elements on chromosomes, or alpha helices in proteins. As a
Java interface, <code class="highlighter-rouge">Feature</code> has the following basic properties:</p>

<ul>
  <li>A location within the sequence, represented by a <code class="highlighter-rouge">Location</code> object.
This has a defined start and end (equal in the case of point
locations), and may or may not be contiguous.</li>
  <li>A type (for instance, “gene” or “helix”).</li>
  <li>A source (often the name of the program which discovered the
feature.</li>
  <li>An <code class="highlighter-rouge">Annotation</code> object, which can contain any other data.</li>
</ul>

<p>In addition, all features have a place in a ‘tree’ of features, attached
to a sequence. Features cannot be created independently of a sequence.</p>

<p>If a large class of features exists which have important properties over
and above those represented in the <code class="highlighter-rouge">Feature</code> interface, a sub-interface
of <code class="highlighter-rouge">Feature</code> may be defined. Currently, there is only one such
sub-interface in the BioJava core: <code class="highlighter-rouge">StrandedFeature</code>. This is used for
features in duplex DNA which have a defined directionality. For
instance, genes would normally be represented with <code class="highlighter-rouge">StrandedFeature</code>,
while some kinds of regulatory region might be plain features.</p>

<p>Sets of features are stored in objects implementing the <code class="highlighter-rouge">FeatureHolder</code>
interface. <code class="highlighter-rouge">Sequence</code> is a sub-interface of <code class="highlighter-rouge">FeatureHolder</code>. <code class="highlighter-rouge">Feature</code>
itself also extends <code class="highlighter-rouge">FeatureHolder</code>, giving the possibility of
representing ‘nested’ features. For instance, a feature representing a
large genetic regulatory region might contain sub-features annotating
individual transcription factor binding sites. The recursive method
below will print a simple text representation of a tree of features:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void printFeatures(FeatureHolder fh, PrintWriter pw, String prefix)
{
    for (Iterator i = fh.features(); i.hasNext(); ) {
        Feature f = (Feature) i.next();
    pw.print(prefix);
    pw.print(f.getType());
    pw.print(" at ");
    pw.print(f.getLocation().toString());
    pw.println();
    printFeatures(f, pw, prefix + "    ");
    }
}
</code></pre>
</div>

<p>All <code class="highlighter-rouge">Feature</code> implementations include two methods which indicate how it
fits into a feature tree. <code class="highlighter-rouge">getParent</code> returns the <code class="highlighter-rouge">FeatureHolder</code> object
(<code class="highlighter-rouge">Sequence</code> or <code class="highlighter-rouge">Feature</code>) which is the feature’s immediate parent, while
<code class="highlighter-rouge">getSequence</code> returns the <code class="highlighter-rouge">Sequence</code> object which is the root of the
tree. <code class="highlighter-rouge">Feature</code> objects are always associated with a specific sequence,
and always have exactly one parent <code class="highlighter-rouge">FeatureHolder</code>.</p>

<h2 id="creating-new-features">Creating new features</h2>

<p>It is expected that there will never be any publicly visible
implementations of <code class="highlighter-rouge">Feature</code> or its sub-interfaces. Instead, features
should be produced using the <code class="highlighter-rouge">createFeature</code> method of a <code class="highlighter-rouge">FeatureHolder</code>
object. This ensures that there are no ‘orphan’ features, not properly
attached to a parent sequence. It also gives <code class="highlighter-rouge">Sequence</code> implementors the
chance to control the attachment of features to their sequence class.
Some sequences may only accept certain kinds of features. Other
implementations, especially those intimately coupled with database
storage mechanisms, may wish to use their own special implementations of
the <code class="highlighter-rouge">Feature</code> interface.</p>

<p>The <code class="highlighter-rouge">createFeature</code> method has the following signature:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public Feature createFeature(Feature.Template template);
</code></pre>
</div>

<p>there is no requirement that a particular <code class="highlighter-rouge">FeatureHolder</code> object should
include a working implementation of this method. If it is not possible
to create a new child feature, <code class="highlighter-rouge">UnsupportedOperationException</code> will be
thrown. In particular, this method is only implemented by <code class="highlighter-rouge">Sequence</code> and
<code class="highlighter-rouge">Feature</code> objects. When <code class="highlighter-rouge">FeatureHolder</code> instances are used to return
arbitrary ‘bags’ of features, they will never support this method.</p>

<p><code class="highlighter-rouge">Feature.Template</code> is a concrete nested class of the <code class="highlighter-rouge">Feature</code>
interface. It just contains public fields corresponding to each property
of <code class="highlighter-rouge">Feature</code>. A feature could be attached to a sequence as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Feature.Template template = new Feature.Template();
template.type = "TestFeature";
template.source = "Test";
template.location = new RangeLocation(100, 200);
template.annotation = Annotation.EMPTY_ANNOTATION;
mySequence.createFeature(template);
</code></pre>
</div>

<p>Every sub-interface of <code class="highlighter-rouge">Feature</code> should have a nested class, also named
<code class="highlighter-rouge">Template</code>, which extends <code class="highlighter-rouge">Feature.Template</code> and adds any extra fields
needed to construct that specialized kind of feature.</p>

<category:tutorial>
</category:tutorial>
