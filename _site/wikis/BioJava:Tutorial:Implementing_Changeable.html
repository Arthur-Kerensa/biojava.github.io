<p><strong>By <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#109;&#114;&#112;&#064;&#115;&#097;&#110;&#103;&#101;&#114;&#046;&#097;&#099;&#046;&#117;&#107;">Matthew Pocock</a></strong></p>

<p>We are going to implement a simple <code class="highlighter-rouge">ChangeEvent</code> source that stores a
string <code class="highlighter-rouge">name</code> property and can inform other objects if this name
changes. By the end of this tutorial you should be comefortable with the
general issues surrounding implementing event sources and for ensuring
that resources are allocated as needed.</p>

<h2 id="the-nameable-interface">The Nameable interface</h2>

<p>By convention, BioJava always defines changes in an interface. This
allows a range of implementations to provide a unified API to a change
without mandaiting them to shair any code. We will define the <code class="highlighter-rouge">Nameable</code>
interface.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package demos.Changeable;

import org.biojava.utils.*;

public interface Nameable extends Changeable {
</code></pre>
</div>

<p>The first thing we must do is define the <code class="highlighter-rouge">ChangeType</code> that indicates
that the name has changed. By convention, it is a public static final
field of the interface and is named in upper-case, with word boundaries
indicated by underscores. The constructor needs a description, and also
the name of the current class and the name of the field. This is so that
during serialization, the <code class="highlighter-rouge">ChangeType</code> instance will resolve correctly
both over time and between VMs.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  /**
   * The ChangeType that indicates that the name property has changed.
   */
  public static final ChangeType NAME = new ChangeType(
    "The name has changed.", // human-readable description
    "demos.Changeable",      // the current class name
    "NAME"                   // field name
  );
</code></pre>
</div>

<p>Now we have the definition of the accessor methods.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  /**
   * Return the name associated with this Nameable.
   *
   * @return the name property
   */
  public String getName();

  /**
   * Change the name associated with this Nameable.
   *
   * @param the new value for the name property
   * @throws ChangeVetoException if for any reason the name could not be set
   */
  public void setName(String name)
  throws ChangeVetoException;
}
</code></pre>
</div>

<p>and that’s it for the <code class="highlighter-rouge">Nameable</code> interface.</p>

<h2 id="the-simplest-implementation---extend-abstractchangeable">The simplest implementation - extend AbstractChangeable</h2>

<p>The simplest way to implement the <code class="highlighter-rouge">Nameable</code> interface is to inherit
from <code class="highlighter-rouge">AbstractChangeable</code>. This is the aproach we will take here.
Firstly we will define the class and add a couple of constructors.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package demos.Changeable;

import org.biojava.utils.*;

public class SimpleChangeable
extends AbstractChangeable
implements Nameable {
  private String name;

  public SimpleChangeable() {
    this(null);
  }

  public SimpleChangeable(String name) {
    this.name = name;
  }
</code></pre>
</div>

<p>The getName method can also be written in the obvious way.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  public String getName() {
    return name;
  }
</code></pre>
</div>

<p>The process of informing listeners requires some bagage to be present -
in particular, the list of listeners. This would impose overhead on all
instances of <code class="highlighter-rouge">Changeable</code>, regardless of whether listeners exist or not.
The solution to this is to lazily instantiate the supporting objects.
Fortunately, <code class="highlighter-rouge">AbstractChangeable</code> handles all of this for you. The two
methods you need to use are <code class="highlighter-rouge">hasListeners()</code>, which will return <code class="highlighter-rouge">true</code>
if there are any listeners at all and false otherwise. If there are no
listeners, then the name can be set directly.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  public void setName(String name)
  throws ChangeVetoException {
    if(!hasListeners()) {
      this.name = name;
    } else {
</code></pre>
</div>

<p>If there are listeners, then the method <code class="highlighter-rouge">getChangeSupport</code> is used to
retrieve the <code class="highlighter-rouge">ChangeSupport</code> instance that maintains the listeners list.
You should then synchronize on this to ensure that no listeners are
added or removed while the name is being set.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>      ChangeSupport cs = getChangeSupport(Nameable.NAME);
      synchronized(cs) {
</code></pre>
</div>

<p>Next, we make a new ChangeEvent to describe how the object wishes to
alter, we fire a preChange notification to the listeners so that they
have a chance to veto the change, we make the change and lastly we
inform the listeners that the change has been made.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>        ChangeEvent ce = new ChangeEvent(this, Nameable.NAME, name, this.name);
        cs.firePreChange(ce);
        this.name = name;
        cs.firePostChange(ce);
      }
    }
  }
}
</code></pre>
</div>

<p>That is the end of the implementation.</p>

<h2 id="using-changesupport-directly">Using ChangeSupport directly</h2>

<p>The previous example used <code class="highlighter-rouge">ChangeSupport</code> to store a list of listeners
but via the <code class="highlighter-rouge">AbstractChangeable</code> class. Java only allows classes to
inherit from one other class. This means that if you have a class that
must implement <code class="highlighter-rouge">Changeability</code> but already is derived from another
class, you can’t use <code class="highlighter-rouge">AbstractChangeable</code>. You can, however, still use
<code class="highlighter-rouge">ChangeSupport</code>. To illustrate this, we will look at the code in
<code class="highlighter-rouge">AbstractChangeable</code> that wires in the <code class="highlighter-rouge">ChangeSupport</code> object.</p>

<p><code class="highlighter-rouge">AbstractChangeable</code> is in the package <code class="highlighter-rouge">org.biojava.utils</code>, and
implements <code class="highlighter-rouge">Changeable</code>. It is abstract as you must sub-class to provide
code to actualy fire events.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package org.biojava.utils;

public abstract class AbstractChangeable implements Changeable {
</code></pre>
</div>

<p>The listener networks are not preserved during serialization. This is
partly to prevent arbitrarily large networks of objects being dumped,
and partly because listeners can be safely added in custom
serialization/deserialization code.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  private transient ChangeSupport changeSupport = null;
</code></pre>
</div>

<p>The hasListeners method is implemented in the obvious way. It is
protected, because it is realy a memory optimization method, and not
part of the external interface of extending classes.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  protected boolean hasListeners() {
    return changeSupport != null;
  }
</code></pre>
</div>

<p>To retrieve the <code class="highlighter-rouge">ChangeSupport</code> delegate, we need to provide an access
method. Again, this is protected and implemented in the obvious way.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  protected ChangeSupport getChangeSupport(ChangeType ct) {
    if(changeSupport == null) {
      changeSupport = new ChangeSupport();
    }

    return changeSupport;
  }
</code></pre>
</div>

<p>Some subclasses may wish to override this method and lazily instantiate
resoruces when the first listener for a particular <code class="highlighter-rouge">ChangeType</code> is
added. In this case, the overriden method should first call
<code class="highlighter-rouge">super.getChangeSupport</code> and then perform any checkes it wishes.</p>

<p>Now that the protected methods are in place, we can provide the bodies
of the listener management methods. These firstly use <code class="highlighter-rouge">getChangeSupport</code>
to retrieve the delegate, and then ask it to add or remove a listener.
We must synchronize on the delegate to make sure that it maintains in a
consistent state.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  public void addChangeListener(ChangeListener cl) {
    ChangeSupport cs = getChangeSupport(null);
    synchronized(cs) {
      cs.addChangeListener(cl);
    }
  }

  public void addChangeListener(ChangeListener cl, ChangeType ct) {
    ChangeSupport cs = getChangeSupport(ct);
    synchronized(cs) {
      cs.addChangeListener(cl, ct);
    }
  }

  public void removeChangeListener(ChangeListener cl) {
    ChangeSupport cs = getChangeSupport(null);
    synchronized(cs) {
      cs.removeChangeListener(cl);
    }
  }

  public void removeChangeListener(ChangeListener cl, ChangeType ct) {
    ChangeSupport cs = getChangeSupport(ct);
    synchronized(cs) {
      cs.removeChangeListener(cl, ct);
    }
  }
}
</code></pre>
</div>

<p>And that is the end of the class. You should be able to cut-and-paste
this code into your own <code class="highlighter-rouge">Changeable</code> objects to implement the basic
delegate-management.</p>

<h2 id="using-an-abstract-class-to-provide-the-event-handeling">Using an abstract class to provide the event handeling</h2>

<p>Often there are a number of implementatoins of an interface that are
almost exactly the same except for the particulars of how data is
stored. It is a shame to write the event code multiple times. A useful
design pattern for this is to provide an abstract class that takes care
of all the synchronization issues and calles stub methods to perform the
actual access to object state. Here is an example of that for the
<code class="highlighter-rouge">Nameable</code> class.</p>

<p>The abstract class will look like this.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public abstract class AbstractNameable implements Nameable {
  public void setName(String name)
  throws ChangeVetoException {
    if(!hasListeners()) {
      setNameImpl(name);
    } else {
      ChangeSupport cs = getChangeSupport(Nameable.NAME);
      synchronized(cs) {
        ChangeEvent ce = new ChangeEvent(this, Nameable.NAME, name, this.name);
        cs.firePreChange(ce);
        setNameImpl(name);
        cs.firePostChange(ce);
      }
    }
  }

  protected abstract void setNameImpl(String name)
  throws ChangeVetoException;
}
</code></pre>
</div>

<p>The implementation would look something like this.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class MyNameable extends AbstractNameable {
  private String name;

  public String getName() {
    return this.name;
  }

  public void setName(String name)
  throws ChangeVetoException {
    this.name = name;
  }
}
</code></pre>
</div>

<p>This split between the abstract implementation that handles all of the
event guts and a realy light-weight implementation that controls access
to data-storage is very useful in practice, and is used extensively in
BioJava, particularly in the <code class="highlighter-rouge">org.biojava.bio.dist</code> package.</p>

<h2 id="what-next">What next?</h2>

<p>By now, you should be able to define interfaces that are Changeable, and
to write implementations of these interfaces using AbstractChangeable or
by delegating to ChangeSupport directly. For cases where there are many
implementations that differ only in the means of data-storage, you
should be able to factor the Changeablility code into an abstract class,
and subclass this for each form of data-access.</p>

<category:tutorial>
</category:tutorial>
