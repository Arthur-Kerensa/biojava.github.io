<p>This page will include all info and docs about our efforts in the 2007
Google Summer of Code as part of the NESCent phyloinformatics group.</p>

<p>**<apis for="" biojava:="" project="" plan="">**</apis></p>

<p><em>Week 0 (~ May 20th) :</em> Building project plan, Program set-up (Java,
Eclipse and BioJava, JGraphT), Reading NEXUS paper, etc.</p>

<hr />

<p><strong>Part I : Development of basic I/O</strong></p>

<hr />

<p><strong><em>Week 1 (May 21st ~ May 27th) Development of basic Input</em></strong></p>

<ul>
  <li>
    <p>Input: Nucleic acid sequences (practice w/ FASTA format and create API
for NEXUS format)</p>
  </li>
  <li>
    <p>Initialization: create objects for each sequence</p>
  </li>
</ul>

<p>Day 1: Practice w/ FASTA parser -done</p>

<p>Day 2: Getting to know NEXUS parser(1) (read and parse the TAXA,
CHARACTER block) -done</p>

<p>Day 3: Getting to know NEXUS parser(2) (TREE block) -done</p>

<p>Day 4: Tree building practice w/ JGraphT
(http://www.jgrapht.org/javadoc/) -done</p>

<p>Day 5/6: Extend functions for NEXUS parser (parse a tree block and
create tree by JGraphT) -done</p>

<hr />

<p><strong><em>Week 2 Development of basic Output (May 28th ~ June 3rd)</em></strong></p>

<ul>
  <li>Output file creation in NEXUS format(converting tree object into NEXUS
format)</li>
</ul>

<p>Day1 &amp; 2 : Finish the NexusToJgraphT code</p>

<p>Day3 : Nexus Tree code for Output(1) (create JgraphT object &amp; Convert it
to Nexus Tree Object) -done (method: AddTree)</p>

<p>Day4 : Nexus Tree code for Output (2) (generating an output string) -
done (testing file: SampleAddTree.java)</p>

<p>Day5 : Nexus Tree code for Output (3) (debugging) -done</p>

<p>Day6 : Documentation -done (getTree, addTree)</p>

<hr />

<p><strong>Part II: Distance method (multiple hit correction method)</strong></p>

<hr />

<p><strong><em>Week 3 Jukes-Cantor</em></strong> -Devoloping API for Jukes-Cantor method</p>

<p>Day1: Method for Nexus Parser -done(getTreeAsJGraphT)</p>

<p>Day2 :Jukes-Cantor method review &amp; algorithm study &amp; write sample input
file -done</p>

<p>Day3: program development (1) code for pairwise comparison -done</p>

<p>Day4: program development (2) calculate K( # of nucleotide
substitutions since the divergence) from the pairwise comparison
result -done</p>

<p><code class="highlighter-rouge">    K = -(3/4)*ln(1-(4/3)*p),    p = prob. of two sequences to have different base at certain position</code></p>

<p>Day5: Documentaion &amp; feedback for methods in PartI (getTree, AddTree,
getTreeAsJgrapht) -done</p>

<hr />

<p><strong><em>Week 4 Kimura’s 2-parameter</em></strong></p>

<p>Day1: getting to know CVS and upload file -done</p>

<p>Day2: Kimura’s 2-parameter model reveiw &amp; write sample input file w/
Nexus Parser - done</p>

<p>Day3: program development: code for differenciate
transition/transversion &amp; Calculate K - done</p>

<p><code class="highlighter-rouge">    K = (1/2)*ln(1/(1-2p-q)) + (1/4)*ln(1/(1-2q)),</code><br />
<code class="highlighter-rouge">    </code><br />
<code class="highlighter-rouge">    p: proportion of diff. transition</code><br />
<code class="highlighter-rouge">    q: proportion of diff. transversion</code></p>

<p>Day4: feedback for Multiple correction methods (JukesCantor, Kimura)</p>

<p>Day5: Reviewing UPGMA &amp; N-J method.</p>

<hr />

<p><strong>Part III: Distance based phylogeny reconstruction</strong></p>

<hr />

<p><strong><em>week5 UPGMA method &amp; Neighbor-Joining method</em></strong></p>

<p>Day1: code for UPGMA method(1) - building distance matrix (by
JukesCantor or Kimura’s 2-parameter)</p>

<p>Day2: code for UPGMA method(2) - calculate branch length &amp; build
weighted sub-tree as JGraphT</p>

<p>Day3: code for UPGMA method(3) - collapsing a pair and rebuild distance
matrix</p>

<p>Day4: code for N-J method(1) - build initial star tree &amp; choose a pair
minizimg total branch length</p>

<p>Day5: code for N-J method(2) - collapse a pair &amp; rebuild distance matrix
&amp; iterate</p>

<p>Day6: Revising code (if necessary)</p>

<p>[UPGMA]</p>

<ol>
  <li>
    <p>finding shortest distance within distance matrix</p>
  </li>
  <li>
    <p>calculate branch lengths as distance/2</p>
  </li>
  <li>
    <p>build a sub-tree for that pair</p>
  </li>
  <li>
    <p>collapse a pair (changes distance into 0)</p>
  </li>
  <li>
    <p>repeat process expanding/combining trees</p>
  </li>
</ol>

<p>[N-J]</p>

<ol>
  <li>
    <p>S = total branch length of tree</p>
  </li>
  <li>
    <p>separate pair of taxa from all others</p>
  </li>
  <li>
    <p>choose pair of taxa that minimizes S</p>
  </li>
  <li>
    <p>build a sub-tree for that pair</p>
  </li>
  <li>
    <p>collapse pair as distance and recalculate distance matrix</p>
  </li>
  <li>
    <p>next pair that gives smallest S is chosen</p>
  </li>
  <li>
    <p>repeat until complete</p>
  </li>
</ol>

<hr />

<p><strong><em>Week 6 Documentation for Part I &amp; II &amp; III</em></strong> : (JavaDoc and BJ
website)</p>

<p>Day 1: N-J method (1) -done</p>

<p>Day 2: N-J method (2) -done</p>

<p>Day 3: implementing CharactersBlock Parser for UPGMA/N-J method - done</p>

<p>Day 4: Documentation (by format) -done</p>

<p>Day 5: updating wiki page (specifying methods w/ sample codes) - Waiting
for uploading as July 1st.</p>

<hr />

<p><strong>Part III : Maximum Parsimony</strong></p>

<hr />

<p><strong><em>Week 7 Maximum Parsimony Method</em></strong></p>

<p>Day 1: Implementing Taxa &amp; CharactersBlock for
UPGMA/N-J/MaximumParsimony methods -done</p>

<p>Day 2: Revising AddTree method( for weighted tree) -done (currently
being discussed as well)</p>

<p>Day 3: Revising GetTreeAsJgrapht method( for weighted tree) -done
(currently being discussed as well)</p>

<p>Day 4: Code for Maximum Parsimony Method (1) -done</p>

<p>Input: Read Nexus File &amp; Extract MATRIX data (Align sequences &amp; decide
informative sites)</p>

<p>Day 5: Code for Maximum Parsimony Method (2) -changing plans</p>

<p>Building Data Structure : decide all possible tree structures &amp;
initialize variables for those trees.</p>

<hr />

<p><strong><em>Week 8 Maximum Parsimony Method</em></strong></p>

<p>Day 1: Code for Maximum Parsimony Method (2) - done</p>

<p>Building Data Structure : decide all possible tree structures &amp;
initialize variables for those trees.</p>

<p>Day 2: Code for Maximum Parsimony Method (3) - changing plans iterate
the calculation to dicide a tree</p>

<p>Day 3: Revising AddTree &amp; getTreeAsJGraphT method (to allow both
weighted/unweighted tree) - done</p>

<p>Day 4: Debugging for non-symmetric tree structure (1) - done Day 5:
Debugging for non-symmetric tree structure (2) - done</p>

<algorithm> 1. aligning sequences

2. decide informative sites (2 or more differences)

3. create tree type and calculate \# of base changes for that tree

4. repeat step 3 for all informative sites

5. for each tree type, add \# of changes for all sites

6. find the tree with smallest number of changes

------------------------------------------------------------------------

***Week 9 Maximum Parsimony Method***

Day 1: Debugging for AddTreeMethod (for the non-symmetric tree
structure) -done

Day 2: Debugging for AddTreeMethod (for the non-symmetric tree
structure) -done

Day 3: Maximum Parsimony Method - solve the problem w/ \# of trees

Day 4: Maximum Parsimony Method - getting help for Jgrapht type array

Day 5: Maximum Parsimony Method -

-   Plan for Maximum Parsimony Method has been changed!

------------------------------------------------------------------------

***Week 10 Maximum Parsimony Method***

------------------------------------------------------------------------

Day 1: Debugging AddTree Method &amp; commit the source code -done

Day 2: PHYLIP installation &amp; learning how to use it - done
(http://evolution.genetics.washington.edu/phylip.html)

Day 3: Practicing PHYLIP with MP/ML/Bootstrap methods - done

Day 4: Developing the wrapper for PHYLIP MP method (1) - parser (done)

Day 5: Developing the wrapper for PHYLIP MP method (2) - builing objects
from the output (to be worked out)

**Part IV : Maximum Likelihood**

------------------------------------------------------------------------

*Week 11 Maxumum Likelihood Method*

Day 1: Developing the wrapper for PHYLIP MP method (1) - parser

Day 2: Developing the wrapper for PHYLIP MP method (2) - builing objects
from the output

Day 3: Developing the wrapper for PHYLIP ML method (1) - parser

Day 4: Developing the wrapper for PHYLIP ML method (2) - builing objects
from the output

Day 5: Debugging

**Part V : Phylogeny supporting method**

*Week 12 Bootstrap method*

------------------------------------------------------------------------

*Week 11 Maxumum Likelihood Method*

Day 1: Developing the wrapper for PHYLIP MP method (2) - execute()
method <debugging>

Day 2: Developing the wrapper for PHYLIP MP method (2) - execute()
method <debugging>

Day 3: Developing the wrapper for PHYLIP MP method (3) - builing objects
from the output

Day 4: Developing the wrapper for PHYLIP ML method (1) - parser

Day 5: Developing the wrapper for PHYLIP ML method (2) - builing objects
from the output

Day 6: Debugging

1. replicate alignments

- taking the original sequence alignment

- entire column is randomly sampled(w/ replacement)

2. for each re-sampled replicate alignment, reconstruct phylogeny based
on the method

3. count the number of replicates that each internal branch of the
original tree is found

*Week 13 Documenting: part IV &amp; V*

'''

[documentation for the methods [1](http://biojava.org/wiki/BioJava:PhyloSOC07_doc)]
-----------------------------------------------------------------------------------

'''
</debugging></debugging></algorithm>
