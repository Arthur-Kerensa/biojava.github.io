<p>by <strong><a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#098;&#105;&#111;&#105;&#110;&#102;&#111;&#114;&#109;&#097;&#116;&#105;&#099;&#115;&#064;&#067;&#097;&#109;&#098;&#114;&#105;&#100;&#103;&#101;&#065;&#110;&#116;&#105;&#098;&#111;&#100;&#121;&#046;&#099;&#111;&#109;">Cambridge Antibody
Technology</a></strong></p>

<p>This section of the BioJava tutorial covers making use of the output
from software used for sequence similarity/homology based searches of
biological databases. The material is presented in a Cook Book fashion
giving practical examples that should be enough to get you going. If you
want to make use of the output from the following programs by using
BioJava, this is a useful tutorial to work through:</p>

<ul>
  <li>NCBI Blast (blastn, blastx, blastp, tblastn, tblastx)</li>
  <li>WU-Blast (blastn, blastx, blastp, tblastn, tblastx)</li>
  <li>or HMMER</li>
</ul>

<p><em>NB Please check the JavaDocs of <code class="highlighter-rouge">BlastLikeSAXParser</code> to see the extent
of support for output from the various applications.</em></p>

<p>The section of BioJava you will be making use of in the tutorial is the
SAX2-compliant event-based parsing framework. After following this
tutorial, you will you be able to not only to deal with output from the
above pieces for bioinformatics software, but also get started with
working with other types of data, such as three-dimensional
macromolecular structures which are also supported by the framework.</p>

<h2 id="what-you-need-to-know-about-the-parsing-framework">What you need to know about the parsing framework</h2>

<p>The framework has been designed in such a way that you don’t need to
understand the details of how it works in order to use it. This is
achieved by providing facade classes that are simple to use. For parsing
Blast-like output, the facade class you need to use is
<code class="highlighter-rouge">org.biojava.bio.program.sax.BlastLikeSAXParser</code>. You pass streams of
data to this class, and the framework will do the rest. As the name
suggests, this class is actually a SAX parser, and implements the
<code class="highlighter-rouge">org.xml.sax.XMLReader</code> interface. You are thus able to treat the output
data as thought it is in an XML format.</p>

<p>The framework performs the magic of emitting SAX2 events from non-XML
format data. Thus you don’t have to do any parsing yourself. Rather you
will simply be writing XML Content Handlers. The recipes for XML Content
Handlers presented here will point you in the direction of populating
your own (or BioJava) objects with bioinformatics data.</p>

<p>It is also worth noting, that the SAX events that the framework emits
are consistent with a scenario where all the pieces of bioinformatics
software above, actually produced identically formatted data.</p>

<h2 id="benefits-of-using-the-framework">Benefits of using the framework</h2>

<ul>
  <li>Allows you to focus on the objects you want to create, and forget
about writing complex parsing code</li>
  <li>Allows you to make use of the output from more pieces of software.
Because of the “concept-based” approach to the representation of
data, many of the Content Handler classes you write can be re-used
with the output of several different programs.</li>
</ul>

<h2 id="recipes">Recipes</h2>

<p>The recipes are simple examples designed to get you up and running
populating objects in the way you want. For each example recipe, two
classes are provided:</p>

<ul>
  <li>An XML Content Handler (this is the class that does the work of
populating objects with data)</li>
  <li>A sample application class that takes blast-like program output and
and sets up for parsing using the Content Handler class.</li>
</ul>

<p><em>NB You will find the complete source code for all the classes described
here the demos section of biojava, in the eventbasedparsing package.</em></p>

<p>After Example 1, the only classes that are described are the XML Content
Hander classes, because the application classes are essentially
identical for all examples.</p>

<p>To help you get going, in addition to the source code for the examples,
there are also several example examples of raw ouput from NCBI-blast,
WU-blast, and HMMER the “files” directory of the demos section of
biojava.</p>

<h3 id="example-1">Example 1</h3>

<p>For all the hits from a search as detailed in the summary section of the
output, prepare a list of Hit Ids. This is an example of a re-useable
Content Handler. The same piece of code works equally well with the
output from multiple flavours of NCBI Blast, WU-Blast, and HMMER.</p>

<h4 id="step-a---create-an-application-that-sets-up-the-parser-and-does-the-parsing">Step A - Create an application that sets up the parser and does the parsing</h4>

<p>The full source is in <code class="highlighter-rouge">eventbasedparsing.TutorialEx1</code>. Because there is
no difference between what you do here, and what you would do to parse
XML files there isn’t much to do. First create a SAX Parser that deals
with Blast-like output.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>XMLReader oParser = (XMLReader) new BlastLikeSAXParser(); 
</code></pre>
</div>

<p>Next choose the Content Handler. In this case, we will be using the
class <code class="highlighter-rouge">TutorialEx1Handler</code>, which takes a reference to an <code class="highlighter-rouge">ArrayList</code> in
the constructor. When the SAX Parser parses the file, the Content
Handler will populate the <code class="highlighter-rouge">ArrayList</code> with Hit Ids from the summary
section of the output.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ContentHandler oHandler =
   (ContentHandler) new TutorialEx1Handler(oDatabaseIdList);  
</code></pre>
</div>

<p>The final step in the set-up is to connect the Content Handler to the
SAX Parser.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>oParser.setContentHandler(oHandler); 
</code></pre>
</div>

<p>For the purposes of the tutorial applications, we will simply be reading
output from files on disk. Create a <code class="highlighter-rouge">FileInputStream</code>, and parse it by
calling the parse method on the SAX Parser.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>oInputFileStream = new FileInputStream(oInput);
oParser.parse(new InputSource(oInputFileStream));
</code></pre>
</div>

<p>Finally, having populated the <code class="highlighter-rouge">ArrayList</code> with HitIds, we simply print
them out.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>System.out.println("Results of parsing");
System.out.println("==================");
for (int i = 0; i &lt; oDatabaseIdList.size();i++) {
      System.out.println(oDatabaseIdList.get(i));
}
</code></pre>
</div>

<h4 id="step-b---create-the-logic-for-parsing">Step B - Create the logic for parsing</h4>

<p>This is simply of matter of writing an XML Content Handler. The full
source is in <code class="highlighter-rouge">eventbasedparsing.TutorialEx1Handler</code>. The logic here is
trivial, we simply wish to identify Hit Ids that are contained within in
the Summary sections of the output data, and add each Hit Id to the
ArrayList.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>if ( (oNameStack.peek().toString().equals("HitId")) &amp;&amp;
     (this.findInStack("Summary") != -1) ) {
   oDatabaseIdList.add(poAtts.getValue("id"));
}
</code></pre>
</div>

<h4 id="running-the-application">Running the application</h4>

<p>After compiling, if you run the application from the demos directory by
typing the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>java eventbasedparsing/TutorialEx1 files/ncbiblast/shortBlastn.out
</code></pre>
</div>

<p>You should see the following output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Results of parsing
==================
U51677
L38477
X80457
</code></pre>
</div>

<category:tutorial>
</category:tutorial>
