<p><strong>By <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#116;&#100;&#050;&#064;&#115;&#097;&#110;&#103;&#101;&#114;&#046;&#097;&#099;&#046;&#117;&#107;">Thomas Down</a></strong></p>

<p>This chapter covers the BioJava support for handling biological sequence
data available in the form of files. It covers API provided by the
package <code class="highlighter-rouge">org.biojava.bio.seq.io</code>. For a complete overview of the API
provided in this package, consult the JavaDoc API documentation (<a href="http://www.biojava.org/docs/api1.8/">latest
biojava 1.8</a>).</p>

<p><strong>NOTE:</strong> this chapter has been updated for BioJava release 1.2.</p>

<h2 id="getting-started-with-sequence-io">Getting started with sequence I/O</h2>

<p>The BioJava sequence I/O code is designed to be flexible and easy to
adapt for a wide variety of purposes. However, if you don’t need this
flexibility, there are some convenience methods which set up the parsers
for reading a variety of common formats. All these methods take a Java
<code class="highlighter-rouge">BufferedReader</code> object, and return an iterator which allows you to scan
through the sequences in a file. For example:</p>

<java>BufferedReader br = new BufferedReader(new FileReader(fileName));
SequenceIterator stream = SeqIOTools.readFastaDNA(br); while
(stream.hasNext()) {

`   Sequence seq = stream.nextSequence();`  
`   // do something with the sequence.`

}</java>

<p>For a full list of formats supported in this way, check the Javadoc
documentation for the <code class="highlighter-rouge">SeqIOTools</code> class.</p>

<h2 id="sequence-input-goals">Sequence input goals</h2>

<p>A typical biological sequence file contains three things:</p>

<ul>
  <li>Global information about the sequence (ID, species, etc.)</li>
  <li>Annotations to specific regions of the sequence.</li>
  <li>Actual sequence data</li>
</ul>

<p>Actual file formats need not provide all of these. For instance, FASTA
files contain almost pure sequence data – the only other information is
a single description line for each sequence. At the other extreme, GFF
files are simply a list of features, with no sequence data in the file.</p>

<p>A BioJava Sequence object contains the same kinds of information as a
sequence file. The primary aim of the input architecture is obviously to
take a stream containing sequence file data, and return one or more
<code class="highlighter-rouge">Sequence</code> objects. In addition, there are two other goals:</p>

<p>Decoupled <code class="highlighter-rouge">Sequence</code> creation: BioJava represents sequence data using the <code class="highlighter-rouge">Sequence</code> interface. We allow multiple implementations of this interface, which might be optimized for quite specific purposes. Some implementations will be purely in-memory objects, while others might be persistant objects reflecting data in some kind of database. We want to allow you to create any kind of <code class="highlighter-rouge">Sequence</code> object from a given data stream.</p>

<!-- -->

<p>Pluggable filters: Not all users will wish to exactly reflect the contents of a sequence file as a <code class="highlighter-rouge">Sequence</code> object. Sometimes it is useful to select specific pieces of data from a file, or to change it into some other format. For instance, BioJava has a hierarchical model for features attached to a sequence, whereas many file formats (for instance, EMBL) do not. You might wish to rebuild some kind of feature hierarchy from an EMBL flatfile during the parsing process.</p>

<h2 id="sequencebuilders">SequenceBuilders</h2>

<p>The sequence input framework is based around the <code class="highlighter-rouge">SequenceBuilder</code>
interface (this is actually a sub-interface of <code class="highlighter-rouge">SeqIOListener</code>, but for
these purposes you will usually be using the <code class="highlighter-rouge">SequenceBuilder</code> class).
The role of a sequence builder is to accumulate information discovered
while parsing a sequence file, and ultimately to construct a <code class="highlighter-rouge">Sequence</code>
object.</p>

<p>There are two kinds of <code class="highlighter-rouge">SequenceBuilder</code> implementations:</p>

<p>Builders: These actually contruct new <code class="highlighter-rouge">Sequence</code> objects. Generally, there will just be one Builder implementation for each <code class="highlighter-rouge">Sequence</code> implementation. The basic BioJava library provides one Builder implementation, <code class="highlighter-rouge">SimpleSequenceBuilder</code>, which constructs simple in-memory representations for any kind of sequence data.</p>

<!-- -->

<p>Filters: These don’t construct <code class="highlighter-rouge">Sequence</code> objects themselves, but are chained to another sequence builder. When they are notified of data, they perform some processing, then pass the information on to the next sequence builder in the chain.</p>

<p>Whenever a sequence builder is required, you can either simply provide a
‘Builder’ implementation, or you can create a chain consisting of one or
more ‘Filters’, leading ultimately to a ‘Builder’.</p>

<p>A <code class="highlighter-rouge">SequenceBuilder</code> object should only be used once. If multiple
sequences are being read from a stream, a new <code class="highlighter-rouge">SequenceBuilder</code> (or
chain) should be constructed for each one. For convenience, we provide a
<code class="highlighter-rouge">SequenceBuilderFactory</code> interface, whose sole purpose is to encapsulate
the construction of <code class="highlighter-rouge">SequenceBuilder</code> objects. Each <code class="highlighter-rouge">SequenceBuilder</code>
implementation should provide a suitable factory implementation as well.</p>

<p>For ‘Builder’ implementations, it is usually possible to provide a
‘singleton’ factory object. For <code class="highlighter-rouge">SimpleSequenceBuilder</code> this is the
static field <code class="highlighter-rouge">SimpleSequenceBuilder.FACTORY</code>. For filters, the factory
must be parameterized with another <code class="highlighter-rouge">SequenceBuilderFactory</code> so that a
complete chain can be constructed. For instance:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SequenceBuilderFactory mySBF = 
    new EmblProcessor.Factory(SimpleSequenceBuilder.FACTORY);
</code></pre>
</div>

<p>Authors of new <code class="highlighter-rouge">SequenceBuilder</code> implementations are encouraged to
consider this naming style when implementing <code class="highlighter-rouge">SequenceBuilderFactory</code>.</p>

<h2 id="putting-it-together-streamreader">Putting it together: StreamReader</h2>

<p>The simplest way to use the BioJava sequence input code is to construct
a <code class="highlighter-rouge">StreamReader</code>. The constructor takes four paramters:</p>

<ul>
  <li>A normal Java <code class="highlighter-rouge">BufferedReader</code> object, encapsulating the stream of
data to parse.</li>
  <li>A <code class="highlighter-rouge">SequenceFormat</code> object, which is responsible for actually parsing
sequence data from the stream.</li>
  <li>A <code class="highlighter-rouge">SymbolTokenization</code> object, which represents a mapping from
textual characters to BioJava <code class="highlighter-rouge">Symbol</code> objects.</li>
  <li>A <code class="highlighter-rouge">SequenceBuilderFactory</code> object to support construction of
<code class="highlighter-rouge">Sequence</code> objects.</li>
</ul>

<p>A <code class="highlighter-rouge">StreamReader</code> object might be constructed as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Alphabet dna = DNATools.getDNA();
SymbolTokenization dnaParser = dna.getTokenization("token");
BufferedReader br = new BufferedReader(new FileReader(fileName));
SequenceBuilderFactory sbf = new FastaDescriptionLineParser.Factory(SimpleSequenceBuilder.FACTORY);
StreamReader stream = new StreamReader(br, new FastaFormat(), dnaParser, fact);
</code></pre>
</div>

<p>(This is just a snippet from the example program in <a href="BioJava:Tutorial:Symbols and SymbolLists" title="wikilink">chapter
1</a>, and you may
like to refer back for more information.)</p>

<p>The <code class="highlighter-rouge">StreamReader</code> class implements the <code class="highlighter-rouge">SequenceIterator</code> interface, so
you can easily iterate over all sequences in a stream:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>while (stream.hasNext()) {
    Sequence seq = stream.nextSequence();
    // Perform some processing on seq
}
</code></pre>
</div>

<h2 id="another-application-indexedsequencedb">Another application: IndexedSequenceDB</h2>

<p>As biology enters the post-genomic era, it is common to need to work
with databases of sequence data far too large to fit in available
memory. One way to handle large amounts of sequence is to use a
dedicated database system: either a specialized solution such as
<a href="http://www.acedb.org/">ACeDB</a> or a set of tables in a standard database
application, as used by the <a href="http://www.ensembl.org/">Ensembl</a> project.
If, however, you don’t wish to use one of these solutions, BioJava
offers a simple and efficient sequence database implementation backed by
one or more sequence files on disk. These files can be in any format, so
long as a suitable <code class="highlighter-rouge">SequenceFormat</code> class exists.</p>

<p>As a simple example of an <code class="highlighter-rouge">IndexedSequenceDB</code> in use, the following
servlet retrieves sequences from a large database, and sends them on to
the client in FASTA format. The database could be created using the
<em>CreateIndex</em> and <em>AddFiles</em> programs included in the BioJava demos
directory.</p>

<java>import java.io.\*;

import javax.servlet.\*; import javac.servlet.http.\*;

import org.biojava.bio.symbol.\*; import org.biojava.bio.seq.\*; import
org.biojava.bio.seq.io.\*; import org.biojava.bio.seq.db.\*;

public class SequenceServlet extends HttpServlet {

`   private SequenceDB indexedDB;      // Database to serve`  
`   private SequenceFormat seqFormat;  // Used for writing`

`   public void init(ServletConfig config) `  
`       throws ServletException`  
`   {`  
`       super.init(config);`  
`   String dbName = config.getInitParameter("sequence.db");`  
`   if (dbName == null)`  
`       throw new ServletException("Database not specified");`  
`   try {`  
`           TabIndexStore index = TabIndexStore.open(dbName);`  
`       indexedDB = new IndexedSequenceDB(index);`  
`       } catch (Exception ex) {`  
`       log("Can't open sequence database: " + dbName, ex);`  
`       throw new ServletException();`  
`       }`

`   seqFormat = new FastaFormat();`  
`   }`

`   public void doGet(HttpServletRequest req,`  
`                     HttpServletResponse resp)`  
`       throws ServletException, IOException`  
`   {`  
`       String id = req.getParameter("id");`  
`   if (id == null) {`  
`       resp.sendError(HttpServletResponse.SC_NOT_FOUND,`  
`                      "No id parameter in request");`  
`           return;`  
`   }`

`   try {`  
`       Sequence seq = indexedDB.getSequence(id);`  
`       resp.setContentType("text/plain");`  
`       PrintStream stream = new PrintStream(resp.getOutputStream());`  
`       seqFormat.writeSequence(seq, stream);`  
`       } catch (BioException ex) {`  
`       log("Can't retrieve sequence", ex);`  
`       resp.sendError(HttpServletResponse.SC_NOT_FOUND,`  
`                      "Couldn't load sequence " + id);`  
`       }`  
`   }`

}</java>

<category:tutorial>
</category:tutorial>
