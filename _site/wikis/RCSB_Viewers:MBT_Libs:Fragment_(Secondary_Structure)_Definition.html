<h2 id="notes">Notes</h2>

<ul>
  <li><code class="highlighter-rouge">         If </code><span class="methodname"><code class="highlighter-rouge">deriveFragments()</code></span><code class="highlighter-rouge"> throws an exception, it tries a</code><br />
<code class="highlighter-rouge">         </code><span class="methodname"><code class="highlighter-rouge">loadFragments()</code></span><code class="highlighter-rouge">, again. Might be just to</code><br />
<code class="highlighter-rouge">         clear everything out?</code><br />
<code class="highlighter-rouge">     </code></li>
  <li><code class="highlighter-rouge">       In the loaders, conformation information is ignored. Fragments are </code><em><code class="highlighter-rouge">always</code></em><code class="highlighter-rouge"> derived.</code><br />
<code class="highlighter-rouge">     </code></li>
</ul>

<h2 id="relevent-classes">Relevent Classes</h2>

<ul>
  <li>Structure</li>
  <li>StructureMap</li>
  <li>Conformation* - intermediate container for various conformation
types (COIL, HELIX, etc.)</li>
  <li>StructureComponent* - primarily
<span class="classname">Fragment</span>, in this discussion.</li>
  <li>RangeMap</li>
  <li>Range</li>
  <li>DerivedInformation</li>
  <li>Fragment</li>
</ul>

<h2 id="explanation">Explanation</h2>

<p><code class="highlighter-rouge">     Look in the </code><span class="projectname"><code class="highlighter-rouge">RCSB MBT Libs</code></span><code class="highlighter-rouge"> project, in the source dir</code><br />
<code class="highlighter-rouge">     </code><span class="foldername"><code class="highlighter-rouge">Structure Model</code></span><code class="highlighter-rouge">, package </code><span class="packagename"><code class="highlighter-rouge">org.rcsb.mbt.model</code></span><code class="highlighter-rouge"> for most</code><br />
<code class="highlighter-rouge">     of this (unless otherwise specified).</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">Structure</code></span><code class="highlighter-rouge"> is an abstract class. The loaders derive a helper class from it, and use it to push off all their</code><br />
<code class="highlighter-rouge">     discovered records, without analysis.</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">StructureMap</code></span><code class="highlighter-rouge"> is the real core of the structure model. The information kept here is what is actually contains</code><br />
<code class="highlighter-rouge">     the atom/bond/fragment relationships (The raw types have been moved to </code><span class="packagename"><code class="highlighter-rouge">org.rcsb.mbt.model.interim</code></span><code class="highlighter-rouge">).</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     First, any definitions that are picked up in the file are kept in a list along with all of the other</code><br />
<code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">StructureComponent</code></span><code class="highlighter-rouge">-derived items defined there (Atoms, Residues, Chains, Bonds). This list is kept in the</code><br />
<code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">Structure</code></span><code class="highlighter-rouge"> class (abstract class derived by loader into a loader-specific implementation). They simply consist</code><br />
<code class="highlighter-rouge">     of raw information as they were collected from the file. These classes (</code><span class="classname"><code class="highlighter-rouge">Coil</code></span><code class="highlighter-rouge">, </code><span class="classname"><code class="highlighter-rouge">Helix</code></span><code class="highlighter-rouge">,</code><br />
<code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">Strand</code></span><code class="highlighter-rouge">, </code><span class="classname"><code class="highlighter-rouge">Turn</code></span><code class="highlighter-rouge">),</code><br />
<code class="highlighter-rouge">     derive from </code><span class="classname"><code class="highlighter-rouge">Conformation</code></span><code class="highlighter-rouge"> (which is derived from </code><span class="classname"><code class="highlighter-rouge">StructureComponent</code></span><code class="highlighter-rouge">).</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     If they exist, these records are examined (in </code><span class="classname"><code class="highlighter-rouge">StructureMap</code></span><code class="highlighter-rouge"> - look for </code><span class="methodname"><code class="highlighter-rouge">generateFragments()</code></span><code class="highlighter-rouge"> and</code><br />
<code class="highlighter-rouge">     </code><span class="methodname"><code class="highlighter-rouge">loadFragments()</code></span><code class="highlighter-rouge">). An intermediate type called </code><span class="classname"><code class="highlighter-rouge">RangeMap</code></span><code class="highlighter-rouge"> is used to store residue ranges for each Conformation</code><br />
<code class="highlighter-rouge">     type found.</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     If they don't exist, then </code><span class="methodname"><code class="highlighter-rouge">deriveFragments()</code></span><code class="highlighter-rouge"> is called, which creates a</code><br />
<code class="highlighter-rouge">     </code><span class="classname"><code class="highlighter-rouge">org.rcsb.mbt.model.util.DerivedInformation</code></span><code class="highlighter-rouge"> object used to synthesize the ranges through a heuristic</code><br />
<code class="highlighter-rouge">     </code><em><code class="highlighter-rouge">Kabsch-Sander</code></em><code class="highlighter-rouge"> is the algorithm cited in the comments.) Basically, it consists of subdividing ranges until the</code><br />
<code class="highlighter-rouge">     conformation is determined. Note the 'Ss'-prefix helper classes. ('Ss' stands for 'SecondaryStructure').</code><br />
<code class="highlighter-rouge">   </code></p>

<p><code class="highlighter-rouge">     Finally, the completed </code><span class="classname"><code class="highlighter-rouge">Range</code></span><code class="highlighter-rouge"> objects are traversed and turned into </code><span class="classname"><code class="highlighter-rouge">Fragment</code></span><br />
<code class="highlighter-rouge">     types, which is the destination</code><br />
<code class="highlighter-rouge">     type and is what ultimately ends up in the </code><span class="classname"><code class="highlighter-rouge"> StructureMap lists. Each fragment has a</code><br />
<code class="highlighter-rouge">     </code><span class="enumeration"><code class="highlighter-rouge">ConformationType</code></span><code class="highlighter-rouge"> (which is</code><br />
<code class="highlighter-rouge">     just another </code><span class="enumeration"><code class="highlighter-rouge">ComponentType</code></span><code class="highlighter-rouge">) set to indicate what conformation it is,</code><br />
<code class="highlighter-rouge">     and a list of residues that make it up.</code><br />
<code class="highlighter-rouge">   </code></span></p>
