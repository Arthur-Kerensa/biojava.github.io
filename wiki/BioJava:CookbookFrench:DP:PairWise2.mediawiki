== Comment faire pour cr&eacute;er un alignement global (algorithme de Needleman-Wunsh) ou local (algorithme de Smith-Waterman) ==

Les alignements de deux s&eacute;quences ont traditionnellement &eacute;t&eacute; obtenues par des approches de programmation dynamique d&eacute;terministique. Deux algorithmes de cette nature sont utilis&eacute;s: l'algorithme de Needleman and Wunsch est utilis&eacute; pour des alignements globaux alors que l'algorithme de Smith-Waterman a &eacute;t&eacute; d&eacute;velopp&eacute; pour les alignements locaux. L'exemple ci-dessous vous montre comment faire l'un ou l'autre gr&acirc;ce aux impl&eacute;mentations de chacun de ces algorithmes retrouv&eacute;es dans le package alignment. Ces classe ne sont pas disponibles dans la version 1.4; vous les retrouverez dans la version biojava-live disponible sur le [http://cvs.biojava.org serveur CVS]. &Eacute;videmment, ils se retrouveront dans la version 1.5 ;-)

L'id&eacute;e derri&egrave;re ces approches est de maintenir un repr&eacute;sentation matricielle d'un graphe d'&eacute;edition, avec des fonctions d'insertion, de d&eacute;l&eacute;tion, de substitution et d'extension de gap; en pratique, l'insertion et la d&eacute;l&eacute;tion sont des op&eacute;rations d'ouverture de gaps au sein de la s&eacute;quence connue de l'un, de la s&eacute;quence inconnue de l'autre). Par programmation dynamique, les &eacute;l&eacute;ments contenus dans la matrice, qui sont des valeurs repr&eacute;sentant la valeur de l'op&eacute;ration &agrave; effectuer, sont calcul&eacute;s. Le parcours permettant d'obtenir le meilleur score produit le meilleur alignement. 

Il est possible d'utiliser des matrices de substitution pour faire la calcul des alignements; elles permettent de calculer la valeur de transition d'un acide amin&eacute; &agrave; un autre. Plusieurs de ces matrices existent et sont disponibles publiquement. Elles peuvent &ecirc;tre t&eacute;l&eacute;charg&eacute;es &agrave; partir du [ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/ NCBI] et sont n&eacute;cessaires pour cet exemple.

Les alignements utilisant des valeurs diff&eacute;rentes pour la valeur et la p&eacute;nalit&eacute; d'une ouverture et son &eacute;longation consument une plus grande quantit&eacute; de m&eacute;moire et de temps par rapport &agrave; des valeurs identiques pour les deux. La raison est qu'il faut maintenir trois matrices pour pr&eacute;server l'information n&eacute;cessaire afin de retrouver le meilleur chemin sur le graphe. Il est n&eacute;cessaire ed maintenir une matrice pour les identit&eacute;s et les substitution, une pour les ouvertures de une position et une pour les ouvertures &eacute;tendues; toutes ces matrices ont une dimensions de <code>query.length()</code> par <code>target.length()</code>.

Les impl&eacute;mentations de ces algorithmes douvent &ecirc;tre initialis&eacute;es avec des valeurs (co&ucirc;ts et p&eacute;nalit&eacute;s) poour chaque op&eacute;ration d'&eacute;dition. Cependant, les matrices de substitution sont des bonifications, tout le contraire d'un co&ucirc;t. La superclasse ''SequenceAlignment'' de chaque algorithme poss&egrave;de une m&eacute;thode pour formatter la sortie de l'alignement. Par cons&eacute;quent, si vous d&eacute;sirez &eacute;crire votre propre algorithme d'alignment ou si vous voulez utiliser [[BioJava:CookbookFrench:DP:PairWise|l'algorithme bas&eacute; sur les mod&egrave;les de Markov]], vous pouvez d&eacute;river votre classe &acirc; partir de la super-classe et appliquer la m&eacute;thode.


== Une d&eacute;mo des classes d'alignement global et local ==

<java>
import java.io.File;

import org.biojava.bio.alignment.NeedlemanWunsch;
import org.biojava.bio.alignment.SequenceAlignment;
import org.biojava.bio.alignment.SmithWaterman;
import org.biojava.bio.alignment.SubstitutionMatrix;
import org.biojava.bio.seq.DNATools;
import org.biojava.bio.seq.Sequence;
import org.biojava.bio.symbol.AlphabetManager;
import org.biojava.bio.symbol.FiniteAlphabet;

/*
 * Created on Mar 28, 2006
 */

/** Demo effectuant l'alignement global et local, successivement,
  * de deux sequences avec affichage des resultats a l'ecran. 
  * L'usage d'une matrice de substitution est necessaire, facilement obtenues via
  * ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/
  * Cette demo ne fonctionne qu'avec des sequences d'ADN. Cependant, les algorithmes fonctionnent 
  * avec n'importe quel Alphabet pourvu qu'une matrice valable existe 
  * Dans cet exemple, la matrice NUC.4.4 est adequate.
  *
  * @author Andreas Dr&auml;ger
  */
public class DeterministicAlignmentDemo {

  /** Cette classe permet l'alignement de deux sequences 
    * pour affichage a l'ecran.
    * @param args: une sequence inconnue et une sequence connue, 
    *   un fichier avec les valeurs de la matrice de subsitution a utiliser.
    * @link ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/
    */
  public static void main (String args[]) {
    if (args.length < 3)
	  throw new Error("Usage: DeterministicAlignmentDemo " +
	                  "querySeq targetSeq substitutionMatrixFile");
    try {
      /* Specification de l'Alphabet des sequences, DNA dans cet exemple.
      *  Pour des sequences proteiques, simplement utiliser
      *  AlphabetManager.alphabetForName("Protein");
      */      
      FiniteAlphabet alphabet = (FiniteAlphabet) AlphabetManager.alphabetForName("DNA");
      
      // Lecture du fichier de la matrice de substitution. 
      // Pour cet exemple, la matrice NUC.4.4 est correcte.
      SubstitutionMatrix matrix = new SubstitutionMatrix(alphabet, new File(args[2]));
      
      // Definition les valeurs des couts par defaut pour l'alignement global.
      SequenceAlignment aligner = new NeedlemanWunsch( 
        alphabet, 
        2,      // insertion
        2,	// deletion
        1,      // gapExtend
        0, 	// match
        3,	// remplacement
        matrix 	// Matrice de substitution
      );

      Sequence query  = DNATools.createDNASequence(args[0], "query");
      Sequence target = DNATools.createDNASequence(args[1], "target");

      // Faire l'alignement et perserver les resultats.
      aligner.pairwiseAlignment(
        // sources
        query, 
      	// sequenceDB
        target
      );

      // Imprimer l'alignement obtenu a l'ecran
      System.out.println("Global alignment with Needleman-Wunsch:\n"+
        aligner.getAlignmentString());	  
	  
      // Effectuer l'alignement local. 
      // Primo, definir la valeur du cout de chaque operation.
      aligner = new SmithWaterman(
        0, // match
        2, // insertion
        3, // replacement 
        2, // deletion
        1, // gapExtend
        matrix); // Matrice de substitution

      // Faire l'alignement et perserver les resultats.
      aligner.pairwiseAlignment(query, target);

      // Imprimer l'alignement obtenu a l'ecran
      System.out.println("\nLocal alignment with Smith-Waterman:\n"+
        aligner.getAlignmentString());
    } catch (Exception exc) {
      exc.printStackTrace();
    }
  }
}
</java>