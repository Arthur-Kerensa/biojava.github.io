---
title: BioJava:CookBook:DP:PairWise2
---

How do I generate a global or local alignment with the Needleman-Wunsch- or the Smith-Waterman-algorithm, respectively?
-----------------------------------------------------------------------------------------------------------------------

Alignments can also be generated by a deterministic aproach. Needleman
and Wunsch defined the problem for global alignments, whereas Smith and
Waterman developed an algorithm for local alignments, which was the
basis for the later [BLAST program](http://www.ncbi.nih.gov/BLAST/). The
example below shows how to use the implementation of both of the
algorithms from the alignment package. It requires BioJava 1.5, so for
testing purposes the biojava-live needs to be downloaded from the cvs.

The idea of these deterministic approaches is to maintain a matrix
representation of an edit graph, which covers the operation insert,
delete, replace and gap extension (insert and delete are gap openings in
the query or the target sequence, respectively). By dynamic programing
the matrix elements, which are costs or scores, respectively, of the
certain operation, is computed. The high scoring (low cost) path through
the matrix gives the best alignment.

Alignments with different scores/expenses for gap opening and gap
extension (affine gap penalties) consume significant more time and
memory as with equal scores for both. The reason is that instead of one
matrix three matrices are needed to remember the best way through the
edit graph. One matrix for matches and replaces, one for gaps of lenght
one and one matrix for extended gaps. All these matrices have the
dimension `query.length()` times `target.length()`.

These implementations of the algorithms need to be initialized with
expenses (costs, penalties) for every edit operation. However, the
substitution matrices use scores, which are the opposit of expenses.

Many scoring matrices have been released for the purpose to evaluate the
transition from one symbol to another one. These can be downloaded at
[1](ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/) and are needed to use
the following example.

A demo of local and global alignments
-------------------------------------

<java> import java.io.File;

import org.biojava.bio.alignment.NeedlemanWunsch; import
org.biojava.bio.alignment.SequenceAlignment; import
org.biojava.bio.alignment.SmithWaterman; import
org.biojava.bio.alignment.SubstitutionMatrix; import
org.biojava.bio.seq.DNATools; import org.biojava.bio.seq.Sequence;
import org.biojava.bio.symbol.AlphabetManager; import
org.biojava.bio.symbol.FiniteAlphabet;

/\*

`* Created on Mar 28, 2006`  
`*/`

/\*\* This is a demo class that performes both a local and a global
alignment

` * from two given sequences. The result is printed on the screen. `  
` * Therfore a substitution matrix file is required, which can be downloaded`  
` * at @link `[`ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/`](ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/)  
` * This demo only works for DNA-Sequences, however, the alignment algorithms`  
` * are able to use any kind of alphabet as long as there is a substitution`  
` * matrix available. For this example the matrix NUC.4.4 is the best one.`  
` *`  
` * @author Andreas Dräger`  
` */`

public class DeterministicAlignmentDemo {

` /** This performs an alignment of two given sequences and `  
`   * prints it on the screen.`  
`   * @param args: a query and a target sequence `  
`   *   and one file containing the substitution matrix to be used.`  
`   * @link `[`ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/`](ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/)  
`   */`  
` public static void main (String args[]) {`  
`   if (args.length < 3)`  
`     throw new Error("Usage: DeterministicAlignmentDemo " +`  
`                     "querySeq targetSeq substitutionMatrixFile");`  
`   try {`  
`     // The alphabet of the sequences. For this example DNA is choosen.`  
`     FiniteAlphabet alphabet = (FiniteAlphabet) AlphabetManager.alphabetForName("DNA");`  
`     // Read the substitution matrix file. `  
`     // For this example the matrix NUC.4.4 is good.`  
`     SubstitutionMatrix matrix = new SubstitutionMatrix(alphabet, new File(args[2]));`  
`     // Define the default costs for sequence manipulation for the global alignment.`  
`     SequenceAlignment aligner = new NeedlemanWunsch( `  
`       alphabet, `  
`       2,      // insert`  
`       2,  // delete`  
`       1,      // gapExtend`  
`       0,  // match`  
`       3,  // replace`  
`       matrix  // SubstitutionMatrix`  
`     );`  
`     Sequence query  = DNATools.createDNASequence(args[0], "query");`  
`     Sequence target = DNATools.createDNASequence(args[1], "target");`  
`     // Perform an alignment and save the results.`  
`     aligner.pairwiseAlignment(`  
`       // sources`  
`       query, `  
`       // sequenceDB`  
`       target`  
`     );`  
`     // Print the alignment to the screen`  
`     System.out.println("global alignment with NeedlemanWunsch:\n"+`  
`       aligner.getAlignmentString());    `  
`     `  
`     // Perform a local alginment from the sequences. `  
`     // Firstly, define the expenses for every single operation.`  
`     aligner = new SmithWaterman(`  
`       0, // match`  
`       2, // insert`  
`       3, // replace `  
`       2, // delete`  
`       1, // gapExtend`  
`       matrix); // Substitution matrix`  
`     aligner.pairwiseAlignment(query, target);`  
`     System.out.println("\nlocal alignment with SmithWaterman:\n"+`  
`       aligner.getAlignmentString());`  
`   } catch (Exception exc) {`  
`     exc.printStackTrace();`  
`   }`  
` }`

} </java>
