'''By [mailto:mrp@sanger.ac.uk Matthew Pocock]'''

BioJava contains a powerful API for communicating when objects wish to change their state, and potentialy preventing them from changing if it would invalidate the state of another object, all without violating the principals of encapsulation. The main classes are in the <code>org.biojava.utils</code> package and include <code>Changeable</code>, <code>ChangeEvent</code>, <code>ChangeListener</code>, <code>ChangeType</code> and <code>ChangeVetoException</code>. For full descriptions of all the API used here, please consult the {{JavaDoc:Documentation}}. 


== What is the difference between Changeability and Mutability? ==

Many Java objects are mutable. That is, you can invoke methods that change their state. The Collections API supplys mutable implementations of the <code>List</code> interface. There is also a method <code>Collections.immutableList(List l)</code> that returns a view of the underlying list where the mutators throw exceptions. Through this view object there is no way to edit the list. However, if the underlying list is modified then the 'immutable' view will reflect this. That is, although it is immutable, it is still changeable. 

Things get even more complicated in the world of bioinformatics. Many instances need to be mutable with respect to some clients and immutable for others. Also, some processes rely on objects remaining constant throughout. You can't perform a database search reliably if the database is being modified. However, once the search is complete there is no reason not to change the database. This transient immutability can't be modeled using the design pattern used for the collections. The situation above is complicated even further because while a search is going on, every single sequence must be maintained in an uneditable state. However, a search object realy doesn't want to go through the process of modifying every single sequence object. This would be very ineficient. Something more flexible is needed, and the ''Changeability API'' is it.

== What is a ChangeEvent? ==

<code>ChangeEvent</code> extends <code>java.util.EventObject</code> and adds the methods: 

* <code>getChange</code> - the new value 
* <code>getPrevious</code> - the old value 
* <code>getType</code> - the 'type' of event 
* <code>getChained</code> - an event that caused this event to be fired 

In constrast to the classical Java events model, one event class is shared among all types of BioJava events. The 'type' of the event is signaled by the value of the <code>type</code> property. <code>ChangeType</code> is a final class. Each interface that will fire <code>ChangeEvents</code> will have <code>public static final ChangeType</code> fields with descriptive names. ChangeEvent objects store a descriptive name but are always compared with the <code>==</code> operator. This scheme is a type-safe extention of the Swing <code>PropertyChangeEvent</code> system but BioJava interfaces explicitly publish what types of event they may fire.

== ChangeListener: The contract for handling events ==

Objects that wish to be informed of change events must implement the <code>ChangeListener</code> interface. This has just two methods: 

* <code>preChange(ChangeEvent ce)</code> 
* <code>postChange(ChangeEvent ce)</code> 

An object will invoke <code>preChange</code> to inform listeners that it wishes to alter its state. A <code>ChangeListener</code> may fire a <code>ChangeVetoException</code> to prevent this change from taking place. The event source must respect this. Once the event source has finished updating its state, it will invoke the <code>postChangeEvent</code> method with an equivalent <code>ChangeEvent</code> (one with the same values for its properties). The <code>postChange</code> method should then take appropriate action to update the state of the listening object. 

There are two <code>ChangeListener</code> implementations supplied by default. <code>ChangeListener.ALWAYS_VETO</code> always throws a <code>ChangeException</code> in <code>preChange</code>. This object is useful if you wish to unconditionally lock an object's property. In the exceptional circumstance when <code>ChangeListener.ALWAYS_VETO</code> is registered and a <code>postChange</code> is reached, it throws a <code>NestedError</code> with an assertion failure message. This should only be able to happen if the event source is incorrectly implemented. 

<code>ChangeException.LOG_TO_OUT</code> prints all changes out to <code>System.out</code>. If you want to log to a different stream, construct a new instance of <code>ChangeListener.LoggingListener</code> with the stream.

== Using ChangeSupport to implement Changeable ==

To flag that an object is a source of change events, it should implement <code>Changeable</code>. This interface has the following methods: 

* <code>addChangeListener(ChangeListener cl)</code> 
* <code>addChangeListener(ChangeListener cl, ChangeType ct)</code> 
* <code>removeChangeListener(ChangeListener cl)</code> 
* <code>removeChangeListener(ChangeListener cl, ChangeType ct)</code> 

The methods with <code>ChangeType</code> arguments register the listener for that type of event only. The methods without register the listener for all events. Wherever possible, the type of event should be specified. This potentialy allows for lazy instantiation of various resources and will result in fewer events actualy being fired.

<code>ChangeSupport</code> is a utility class that handles 99% of the cases where you wish to implement the <code>Changeable</code> interface. Idealy, you should instantiate one of these objects and then delegate the listener methods to this. In addition to the methods in <code>Changeable</code>, <code>ChangeSupport</code> supplys the methods: 

* <code>firePreChangeEvent(ChangeEvent ce)</code>
* <code>firePostChangeEvent(ChangeEvent ce)</code> 

These methods invoke the <code>preChange</code> and <code>postChange</code> methods of the apropreate listeners. <code>firePreChangeEvent</code> will pass on any <code>ChangeVetoExceptions</code> that the listeners throw. 

<code>AbstractChangeable</code> is an abstract implementation of <code>Changeable</code> that delegates to a <code>ChangeSupport</code>. In the cases where your class does not have to inherit from any class but must implement <code>Changeable</code>, this is a perfect base class. It will lazily instantiate the delegate only when listeners need to be registered. 

In the [[BioJava:Tutorial:ChangeEvent_example_using_Distribution_objects|next tutorial]], we will implement an event source and add some listeners to it. 

{{Tutorial:Footer}}